(* Clear all variables ---------------------------------------*) 
Off[General::"spell"];
ClearAll["Global`*"];
ClearMech[];
KillMech[];


(* Get Mechanical systems commands ---------------------------*)
Needs["MechanicalSystems`Modeler2D`"];



(*======================== IMPORT DATA ==============================*)

(* Import current path ---------------------------------------*) 
currPath = Import["/Volumes/Docs/Projects/Patek_project/pod_model/sims/curr_path.txt",{"Text", "Lines"}];


(* Import parameter values -----------------------------------*)
inParams = Import[StringJoin[currPath, "/input_params.mat"]][[1]];

L1 = inParams[[1]];
L2 = inParams[[2]];
L3 = inParams[[3]];
L4 = inParams[[4]];

EXLocal = inParams[[5]];
EYLocal = inParams[[6]];
FXLocal = inParams[[7]];
FYLocal = inParams[[8]];

theta   = inParams[[9]];
dMass   = inParams[[10]];
dI      = inParams[[11]];
kSpring = inParams[[12]];
Tmax    = inParams[[13]];

simDuration = inParams[[14]];

Clear[inParams];


(* Import time vector ---------------------------------------------*)
tEval = Import[StringJoin[currPath, "/eval_time.mat"]][[1]];


(* Define scaling factors to help numerical stability -------------*)
sL = 1 / L1;
sM = 1 / dMass;
sT = 10^3;


(* Rescale input parameter values with the scale factors ----------*)

dMass = dMass * sM;
dI = dI * sM * sL^2;

L1 = L1 * sL;
L2 = L2 * sL;
L3 = L3 * sL;
L4 = L4 * sL;

EXLocal = EXLocal * sL;
EYLocal = EYLocal * sL;
FXLocal = FXLocal * sL;
FYLocal = FYLocal * sL;

kSpring     = kSpring * (sM * sL^2 / sT^2);
Tmax        = Tmax * (sM * sL^2 / sT^2);
simDuration = simDuration * sT;
tEval       = tEval * sT;


(*=========================== GEOMETRY ====================================*)

(* Define geometry: si is the angle btwn L1 & L4 --------------------------*)

si[theta_] := ArcCos[(h[theta]^2 + L1^2 - L2^2)/(2 h[theta] L1)] + ArcCos[(h[theta]^2 + L4^2 - L3^2)/(2 h[theta] L4)];

h[theta_] := Sqrt[L1^2 + L2^2 - 2 L1 L2 Cos[theta]];


(* Define appendage coordinates ------------------------------------------*)
AX = 0;
AY = 0;
BX = L2 Sin[theta];
BY = L2 Cos[theta];
CX = L4 Sin[si[theta]];
CY = L1 - L4 Cos[si[theta]];
DX = 0;
DY = L1;
EX = BX + EXLocal;
EY = BY - EYLocal;
FX = BX - FXLocal;
FY = EY - FYLocal;

Clear[si]


(* Define body addresses --------------------------------------------------*)
ground = 1; mV = 2; carpus = 3; dactyl = 4;


(* Define bodies ----------------------------------------------------------*)

bd[ground] = Body[ground,
   PointList -> {
     (*P1*){DX, DY}},
   InitialGuess -> {
     {0, 0}, 0}
   ];

bd[mV] = Body[mV,
   PointList -> {
     (*P1*){BX, BY}},
   InitialGuess -> {
     {0, 0}, 0}
   ];

bd[carpus] = Body[carpus,
      PointList -> {
          (*P1*){ CX - BX, CY - BY},
          (*P2*){ EX - BX, EY - BY}},
            InitialGuess -> {
                    {BX, BY}, 0}
            ];
            
bd[dactyl] = Body[dactyl,
         PointList -> {
               (*P1*){FX - EX, FX - EX}},
   Mass -> dMass,
   Inertia -> dI,
         InitialGuess -> {
              {EX, EY}, 0}
         ];

SetBodies[bd[ground], bd[mV], bd[carpus], bd[dactyl]];



(*=========================== CONSTRAINTS ================================*)

(* Constraint 1: Pin joint between ground and mV -------------------------*)
cs[1] = Revolute2[1, Point[ground, 0], Point[mV, 0]];

(* Constraint 2: Fix position at mV joint origin (removed later) ---------*)
cs[2] = RotationLock1[2,  mV, 0];

(* Constraint 3: Pin joint between carpus and mV -------------------------*)
cs[3] = Revolute2[3, Point[carpus, 0], Point[mV, 1]];

(* Constraint 4: Fix distance between ground and top of carpus -----------*)
cs[4] = RelativeDistance1[4, Point[carpus, 1], Point[ground, 1], L4];

(* Constraint 5: Pin btwn carpus and dactyl -----------------------------*)
cs[5] = Revolute2[5, Point[dactyl, 0], Point[carpus, 2]];

(* Constraint 6: Lock rotation btwn carpus & dactyl ---------------------*)
cs[6] = RotationLock1[6, carpus, dactyl, 0];

(* Apply all constraints to the model -----------------------------------*)
SetConstraints[cs[1], cs[2], cs[3], cs[4], cs[5], cs[6]];

(* Check system ---------------------------------------------------------*)
Print["Check system after constraints:" Evaluate[CheckSystem[]]]



(*=========================== LOADS ================================*)

(* Load 1: Moment created by the spring ----------------------------*)
ld[1] = Moment[mV, -(Tmax - kSpring  \[CapitalTheta]2)];

(* Load 2: Drag on the dactyl --------------------------------------*)
ld[2] = Force[dactyl, Axis[Point[dactyl, 1], -Velocity[dactyl, 1]^2], 
   5.0, Magnitude -> Relative];
   
(* Set loads -------------------------------------------------------*)
SetLoads[ld[1], ld[2]]

(* Check system ----------------------------------------------------*)
Print["Check system after loads:" Evaluate[CheckSystem[]]]


(*=========================== SOLVE ================================*)

(* Remove Constraint 2 (fixed angle of the mV)  & define initial conditions *)
fsys = SetFree[2, {Solution -> Dynamic,
    InitialCondition -> {T -> 0, \[CapitalTheta]2d -> 0, \[CapitalTheta]3d -> 0, \[CapitalTheta]4d -> 0, X2d -> 0, Y2d -> 0, X3d -> 0, Y3d -> 0, X4d -> 0, Y4d -> 0}}];
      
(* Solve for kinematics in dynamic model *)      
sol = SolveFree[fsys, simDuration, 
  MakeRules -> {Location, Velocity, Acceleration}]      
      

(*=========================== EXPORT ================================*)    

(* P1 on carpus *)
carp1Kine =
  {((Location[Point[carpus, 1]] /. sol /. {T -> tEval})/
      sL)[[1]], ((Location[Point[carpus, 1]] /. sol /. {T -> tEval})/
      sL)[[2]],
   ((Velocity[Point[carpus, 1]] /. sol /. {T -> tEval})/sL * 
      sT)[[1]], ((Velocity[Point[carpus, 1]] /. sol /. {T -> tEval})/
       sL * sT)[[2]],
   ((Acceleration[Point[carpus, 1]] /. sol /. {T -> tEval})/sL * 
      sT^2)[[1]], ((Acceleration[Point[carpus, 1]] /. 
          sol /. {T -> tEval})/sL * sT^2)[[2]]
   };
Export[StringJoin[currPath, "/carpusP1.mat"], carp1Kine, "MAT"];

(* P2 on carpus *)
carp2Kine =
  {((Location[Point[carpus, 2]] /. sol /. {T -> tEval})/
      sL)[[1]], ((Location[Point[carpus, 2]] /. sol /. {T -> tEval})/
      sL)[[2]],
   ((Velocity[Point[carpus, 2]] /. sol /. {T -> tEval})/sL * 
      sT)[[1]], ((Velocity[Point[carpus, 2]] /. sol /. {T -> tEval})/
       sL * sT)[[2]],
   ((Acceleration[Point[carpus, 2]] /. sol /. {T -> tEval})/sL * 
      sT^2)[[1]], ((Acceleration[Point[carpus, 2]] /. 
          sol /. {T -> tEval})/sL * sT^2)[[2]]
   };
Export[StringJoin[currPath, "/carpusP2.mat"], carp2Kine, "MAT"];

(* P1 on ground *)
gnd1Kine =
  {((Location[Point[ground, 1]] /. sol /. {T -> tEval})/
      sL)[[1]], ((Location[Point[ground, 1]] /. sol /. {T -> tEval})/
      sL)[[2]],
   ((Velocity[Point[ground, 1]] /. sol /. {T -> tEval})/sL * 
      sT)[[1]], ((Velocity[Point[ground, 1]] /. sol /. {T -> tEval})/
       sL * sT)[[2]],
   ((Acceleration[Point[ground, 1]] /. sol /. {T -> tEval})/sL * 
      sT^2)[[1]], ((Acceleration[Point[ground, 1]] /. 
          sol /. {T -> tEval})/sL * sT^2)[[2]]
   };
Export[StringJoin[currPath, "/groundP1.mat"], gnd1Kine, "MAT"];

(* P1 on mV *)
mV1Kine =
  {((Location[Point[mV, 1]] /. sol /. {T -> tEval})/
      sL)[[1]], ((Location[Point[mV, 1]] /. sol /. {T -> tEval})/
      sL)[[2]],
   ((Velocity[Point[mV, 1]] /. sol /. {T -> tEval})/sL * 
      sT)[[1]], ((Velocity[Point[mV, 1]] /. sol /. {T -> tEval})/sL * 
      sT)[[2]],
   ((Acceleration[Point[mV, 1]] /. sol /. {T -> tEval})/sL * 
      sT^2)[[1]], ((Acceleration[Point[mV, 1]] /. 
          sol /. {T -> tEval})/sL * sT^2)[[2]]
   };
Export[StringJoin[currPath, "/mVP1.mat"], mV1Kine, "MAT"];

(* P1 on dactyl *)
dac1Kine =
  {((Location[Point[dactyl, 1]] /. sol /. {T -> tEval})/
      sL)[[1]], ((Location[Point[dactyl, 1]] /. sol /. {T -> tEval})/
      sL)[[2]],
   ((Velocity[Point[dactyl, 1]] /. sol /. {T -> tEval})/sL * 
      sT)[[1]], ((Velocity[Point[dactyl, 1]] /. sol /. {T -> tEval})/
       sL * sT)[[2]],
   ((Acceleration[Point[dactyl, 1]] /. sol /. {T -> tEval})/sL * 
      sT^2)[[1]], ((Acceleration[Point[dactyl, 1]] /. 
          sol /. {T -> tEval})/sL * sT^2)[[2]]
   };
Export[StringJoin[currPath, "/dactylP1.mat"], dac1Kine, "MAT"];





(* Quit Mathematica kernel *) 
Exit[]