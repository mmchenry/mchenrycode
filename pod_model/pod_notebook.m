(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* ::Input:: *)
(*Print["Hello world"]*)


(* ::Section:: *)
(*Define parameter values (instead of importing)*)


(* ::Input:: *)
(*ClearMech[];ClearAll["Global`*"]; Needs["MechanicalSystems`Modeler2D`"];Off[General::"spell"];Off[General::"spelll"];*)


(* ::Text:: *)
(**)
(**)
(*Linkage lengths (SI units)*)


(* ::Input:: *)
(*L1=5.26 *10^-3;*)
(*L2=3.18 *10^-3;*)
(*L3=0.81 *10^-3;*)
(*L4=5.11 *10^-3;*)
(*EXLocal = 1.43 *10^-3 ;*)
(*EYLocal = 1.64 *10^-3 ;*)
(*FXLocal = 5.52 *10^-3 ;*)
(*FYLocal = 4.3 *10^-3;*)


(* ::Text:: *)
(**)
(*Dactyl/propdus mass*)


(* ::Input:: *)
(*dMass = 4.53 *10^-4;*)


(* ::Text:: *)
(**)
(*Dactyl/propdus moment of inertia*)


(* ::Input:: *)
(*dI= 8.16 *10^-8 ; (* (kg m^2) *)*)


(* ::Text:: *)
(**)
(**)
(*Spring at the mV joint (linear spring stiffness (N/m) * L2^2 (approx. distance to force application)*)


(* ::Input:: *)
(*kSpring = (60*10^3) (3.18 *10^-3)^2;    (* Torsion spring stiffness (Nm/rad) *)*)
(**)


(* ::Text:: *)
(*Max torque estimated as max force (29 N in Zack et al paper), times L2 (3.18e-3, approximate distance to force application) *)


(* ::Input:: *)
(*Tmax = 29  (3.18 *10^-3);(* Max torque generated by torsion spring *)*)


(* ::Text:: *)
(**)
(**)
(*Duration of simulation (s)*)


(* ::Input:: *)
(*simDuration = 5 *10^-3;*)


(* ::Text:: *)
(**)
(**)
(*Initial input angle, \[Theta]in, at the mV joint*)


(* ::Input:: *)
(*theta = (66/180) N[\[Pi]];*)


(* ::Section:: *)
(*Import parameter values (instead of defining)*)


(* ::Subsection:: *)
(*Set parameters*)


(* ::Input:: *)
(*KillMech[];ClearMech[];ClearAll["Global`*"]; Needs["MechanicalSystems`Modeler2D`"];Off[General::"spell"];*)


(* ::Input:: *)
(*currPath = Import["/Volumes/Docs/Projects/Patek_project/pod_model/sims/curr_path.txt",{"Text","Lines"}];*)


(* ::Input:: *)
(*inParams = Import[StringJoin[currPath, "/input_params.mat"]][[1]];*)


(* ::Input:: *)
(*tEval = Import[StringJoin[currPath, "/eval_time.mat"]][[1]];*)


(* ::Input:: *)
(*L1 = inParams[[1]];*)
(*L2=inParams[[2]];*)
(*L3=inParams[[3]];*)
(*L4=inParams[[4]];*)
(*EXLocal = inParams[[5]];*)
(*EYLocal=inParams[[6]];*)
(*FXLocal=inParams[[7]];*)
(*FYLocal=inParams[[8]];*)
(*theta=inParams[[9]];*)
(*dMass=inParams[[10]];*)
(*dI=inParams[[11]];*)
(*kSpring=inParams[[12]];*)
(*Tmax=inParams[[13]];*)
(*simDuration=inParams[[14]];*)


(* ::Input:: *)
(*Clear[inParams]*)


(* ::Section:: *)
(*Linkage model *)


(* ::Subsection::Closed:: *)
(*Rescale input parameter values*)


(* ::Text:: *)
(**)
(*Scale Factors (Mutliplers of all parameters -- helps with numerical instabilities)*)


(* ::Input:: *)
(*sL = 1 / L1;*)
(*sM = 1/dMass;*)
(*sT=10^3;*)


(* ::Text:: *)
(**)
(*Apply scale factors to parameter values*)


(* ::Input:: *)
(*dMass = dMass sM;*)
(*dI= dI sM sL^2;*)
(*L1=L1 sL;*)
(*L2=L2 sL;*)
(*L3=L3 sL;*)
(*L4=L4  sL;*)
(*kSpring = kSpring (sM sL^2/sT^2);*)
(*Tmax= Tmax (sM sL^2/sT^2);*)
(*EXLocal = EXLocal sL;*)
(*EYLocal = EYLocal sL;*)
(*FXLocal = FXLocal sL;*)
(*FYLocal  = FYLocal sL;*)
(*simDuration = simDuration sT;*)
(*tEval = tEval*sT;*)


(* ::Subsection::Closed:: *)
(*Calculated parameter values, define model inputs*)


(* ::Text:: *)
(**)
(**)
(*Angle, \[Psi], btwn L1 & L4:*)


(* ::Input:: *)
(*si[theta_]:=ArcCos[(h[theta]^2+L1^2-L2^2)/(2 h[theta] L1)]+ArcCos[(h[theta]^2+L4^2-L3^2)/(2 h[theta] L4)];*)
(*h[theta_]:=Sqrt[L1^2+L2^2-2 L1 L2 Cos[theta]];*)


(* ::Text:: *)
(**)
(**)
(*Check that the geometry is possible (both should be 'True')*)


(* ::Input:: *)
(*L4  < ( L3 + h[theta])*)


(* ::Input:: *)
(*L4  > (  h[theta]-L3)*)


(* ::Text:: *)
(**)
(**)
(*Points on the appendage*)


(* ::Input:: *)
(*AX=0;*)
(*AY= 0;*)
(*BX=L2 Sin[theta];*)
(*BY=L2 Cos[theta];*)
(*CX=L4 Sin[si[theta]];*)
(*CY=L1-L4 Cos[si[theta]];*)
(*DX=0;*)
(*DY=L1;*)
(*EX =BX+ EXLocal;*)
(*EY=BY - EYLocal;*)
(*FX=BX- FXLocal;*)
(*FY=EY-FYLocal;*)


(* ::Input:: *)
(*Clear[si,h]*)


(* ::Text:: *)
(**)
(**)
(*Body addresses*)


(* ::Input:: *)
(*ground = 1; mV = 2;carpus = 3;dactyl = 4;*)


(* ::Text:: *)
(**)
(**)
(*Display initial geometry*)


(* ::Input:: *)
(*offset = .09 L1;*)
(*Show[*)
(*ListPlot[{*)
(*{{AX,AY},{BX,BY}},*)
(*{{CX,CY},{DX,DY}},*)
(*{{BX,BY},{EX,EY},{CX,CY},{BX,BY}},*)
(*{{EX,EY},{FX,FY}}*)
(*},*)
(*PlotMarkers->Automatic,Joined->True,*)
(*Frame->True,AspectRatio->Automatic,*)
(*PlotLabel->"Initial geometry",*)
(*PlotRange->{{-1,1},{-1,1}}],*)
(*Graphics[*)
(*{Text["A",{AX-offset,AY+offset}],Text["B",{BX-offset,BY+offset}],*)
(*Text["C",{CX+offset,CY+offset}],Text["D",{DX-offset,DY+offset}],*)
(*Text["E",{EX+offset,EY-offset}],Text["F",{FX-offset,FY+offset}],*)
(*Text["L1",{Mean[{AX,DX}]-offset,Mean[{AY,DY}]}],*)
(*Text["L2",{Mean[{AX,BX}]-offset,Mean[{AY,BY}]}+offset],*)
(*Text["L3",{Mean[{CX,BX}]-offset,Mean[{CY,BY}]}+offset/2],*)
(*Text["L4",{Mean[{DX,CX}]-offset,Mean[{DY,CY}]}+offset]*)
(*}]*)
(*]*)


(* ::Subsection:: *)
(*Define Bodies*)


(* ::Input:: *)
(*bd[ground] = Body[ground,*)
(*PointList->{*)
(*(*P1*){DX,DY}},*)
(*InitialGuess->{*)
(*{0,0},0}*)
(*];*)


(* ::Input:: *)
(*bd[mV] = Body[mV,*)
(*PointList->{*)
(*(*P1*){BX,BY}},*)
(*InitialGuess->{*)
(*{0,0},0}*)
(*];*)


(* ::Input:: *)
(*bd[carpus] = Body[carpus,*)
(*   PointList -> {*)
(*     (*P1*){ CX - BX, CY - BY},*)
(*     (*P2*){ EX - BX, EY - BY}},*)
(*         InitialGuess -> {*)
(*               {BX, BY}, 0}*)
(*         ];*)


(* ::Input:: *)
(*bd[dactyl] = Body[dactyl,*)
(*      PointList -> {*)
(*          (*P1*){FX - EX, FX - EX}},*)
(*Mass ->dMass,*)
(*Inertia ->dI,*)
(*      InitialGuess -> {*)
(*         {EX, EY}, 0}*)
(*      ];*)


(* ::Input:: *)
(*SetBodies[bd[ground],bd[mV],bd[carpus],bd[dactyl]];*)


(* ::Subsection::Closed:: *)
(*Define constraints*)


(* ::Text:: *)
(**)
(*Pin joint between ground and mV:*)


(* ::Input:: *)
(*cs[1]= Revolute2[1,Point[ground,0],Point[mV,0]];*)


(* ::Text:: *)
(**)
(*Initially fix position of joint at mV origin (removed later):*)


(* ::Input:: *)
(*cs[2] = RotationLock1[2,  mV,0];*)


(* ::Text:: *)
(**)
(*Pin joint between carpus and mV:*)


(* ::Input:: *)
(*cs[3] = Revolute2[3, Point[carpus, 0], Point[mV, 1]];*)


(* ::Text:: *)
(**)
(*Fix distance between ground and top of carpus:*)


(* ::Input:: *)
(*cs[4] = RelativeDistance1[4, Point[carpus, 1], Point[ground, 1], L4];*)


(* ::Text:: *)
(**)
(*Pin btwn carpus and dactyl*)


(* ::Input:: *)
(*cs[5] = Revolute2[5, Point[dactyl, 0], Point[carpus, 2]];*)


(* ::Text:: *)
(**)
(*Lock rotation btwn carpus & dactyl*)


(* ::Input:: *)
(*cs[6] = RotationLock1[6, carpus, dactyl, 0];*)


(* ::Input:: *)
(*SetConstraints[cs[1], cs[2], cs[3], cs[4],cs[5],cs[6]];*)


(* ::Input:: *)
(*Print["Check system after constraints:" Evaluate[CheckSystem[]]]*)


(* ::Subsection::Closed:: *)
(*Evaluate kinematic model*)


(* ::Text:: *)
(*SetParameters[{*)
(*   (*Torsion spring stiffness*)  theta -> \[Theta]*)
(*   }];*)


(* ::Input:: *)
(*graph=Graphics[{*)
(*(*ground*){RGBColor[0,0,1],Bar[Axis[ground,0,1],10^-4 sL,10^-4 sL]},*)
(*(*mV*){RGBColor[0,.5,.5],Bar[Line[mV,0,1],10^-4 sL,10^-4 sL]},*)
(*(*carpus*){RGBColor[1,0,0],Bar[Line[carpus,0,1],10^-4 sL,10^-4 sL]},*)
(*(*dactyl*){RGBColor[0,1,0],Bar[Line[dactyl,0,1],10^-4 sL,10^-4 sL]}*)
(*},*)
(*Frame->True,*)
(*AspectRatio->Automatic,*)
(*GridLines->Automatic,*)
(*PlotRange->{{-1,1.5},{-2,1}}*)
(*];*)
(**)
(*Show[graph/.SolveMech[]]*)


(* ::Input:: *)
(*Evaluate[{Angle[mV,1]}/.SolveMech[]] (180/\[Pi])*)


(* ::Subsection::Closed:: *)
(*Define Loads*)


(* ::Text:: *)
(**)
(*Moment created by the spring*)


(* ::Input:: *)
(*ld[1]=Moment[mV,-(Tmax-kSpring  \[CapitalTheta]2)];*)


(* ::Text:: *)
(**)
(*Drag on dactyl*)


(* ::Input:: *)
(*ld[2] = Force[dactyl, Axis[Point[dactyl, 1], -Velocity[dactyl,1]^2],5.0,Magnitude->Relative];*)


(* ::Text:: *)
(*TODO: Add Acceleration reaction on dactyl*)


(* ::Input:: *)
(*SetLoads[ld[1],ld[2]]*)


(* ::Input:: *)
(*Print["Check system after loads:" Evaluate[CheckSystem[]]]*)


(* ::Subsection::Closed:: *)
(*Find solution*)


(* ::Text:: *)
(*Solution with the 4-bar linkage constrained from moving:*)


(* ::Text:: *)
(*Remove constraint 2 (fixed angle of the mV)  & define initial conditions*)


(* ::Input:: *)
(*fsys = SetFree[2,{Solution->Dynamic,*)
(*InitialCondition->{T->0,\[CapitalTheta]2d->0,\[CapitalTheta]3d->0,\[CapitalTheta]4d->0,X2d->0,Y2d->0,X3d->0,Y3d->0,X4d->0,Y4d->0}}];*)


(* ::Text:: *)
(*SolveFree[fsys]*)


(* ::Input:: *)
(*sol=SolveFree[fsys,simDuration,MakeRules->{Location,Velocity,Acceleration}]*)


(* ::Subsection::Closed:: *)
(*Simulation diagnostics (for debugging)*)


(* ::Input:: *)
(*Constraints[1]/.sol*)
(*Constraints[3]/.sol*)
(*Constraints[4]/.sol*)


(* ::Input:: *)
(*StepMech[]*)


(* ::Input:: *)
(*Loads[{mV,carpus}]*)


(* ::Subsection::Closed:: *)
(*Draw bodies*)


graph = Graphics[{
{RGBColor[0, 0, 1], Bar[Line[ground, 0, 1], sL/10^4, sL/10^4]}, 
{RGBColor[0, 0.5, 0.5], Bar[Line[mV, 0, 1], sL/10^4, sL/10^4]}, 
{RGBColor[1, 0, 0], Bar[Line[carpus, 0, 1], sL/10^4, sL/10^4]}, 
{RGBColor[0, 1, 0], Bar[Line[dactyl, 0, 1], sL/10^4, sL/10^4]}}, 
Frame -> True, AspectRatio -> Automatic, GridLines -> Automatic]; 


(* ::Input:: *)
(*Show[graph/.(sol/.{T->0*simDuration})]*)


(* ::Text:: *)
(*numPlot = 10; GraphicsGrid[{graph /. (sol /. Table[{T -> i}, {i, 0, simDuration, simDuration/numPlot}] )}]*)


(* ::Text:: *)
(*Animate[Show[graph /. (sol /. {T -> i})], {i, 0, simDuration, .1}]*)


(* ::Subsection::Closed:: *)
(*Graph results*)


(* ::Text:: *)
(**)
(*Theta (angle btwn mV and ground (L1))*)


(* ::Input:: *)
(*Plot[Evaluate[{Angle[ground,1]-Angle[mV,1]}/.sol] (180/\[Pi]),{T,0,simDuration}]*)


(* ::Text:: *)
(**)
(*Angle of mV in global frame of reference*)


(* ::Input:: *)
(*Plot[Evaluate[{ \[CapitalTheta]2}/.sol] (180/\[Pi]),{T,0,simDuration}]*)


(* ::Text:: *)
(**)
(*Distance between point on dactyl and origin*)


(* ::Input:: *)
(*Plot[Evaluate[{Distance[Point[dactyl,1],{0,0}]}/.sol] (180/\[Pi]),{T,0,simDuration}]*)


(* ::Subsection:: *)
(*Export data*)


(* ::Input:: *)
(*(* P1 on carpus *)*)
(*carp1Kine=*)
(*{((Location[Point[carpus,1]]/.sol/.{T->tEval})/sL)[[1]],((Location[Point[carpus,1]]/.sol/.{T->tEval})/sL)[[2]],*)
(*((Velocity[Point[carpus,1]]/.sol/.{T->tEval})/sL * sT)[[1]],((Velocity[Point[carpus,1]]/.sol/.{T->tEval})/sL * sT)[[2]],*)
(*((Acceleration[Point[carpus,1]]/.sol/.{T->tEval})/sL * sT^2)[[1]],((Acceleration[Point[carpus,1]]/.sol/.{T->tEval})/sL * sT^2)[[2]]*)
(*};*)
(*Export[StringJoin[currPath, "/carpusP1.mat"],carp1Kine,"MAT"];*)


(* ::Input:: *)
(*(* P2 on carpus *)*)
(*carp2Kine=*)
(*{((Location[Point[carpus,2]]/.sol/.{T->tEval})/sL)[[1]],((Location[Point[carpus,2]]/.sol/.{T->tEval})/sL)[[2]],*)
(*((Velocity[Point[carpus,2]]/.sol/.{T->tEval})/sL * sT)[[1]],((Velocity[Point[carpus,2]]/.sol/.{T->tEval})/sL * sT)[[2]],*)
(*((Acceleration[Point[carpus,2]]/.sol/.{T->tEval})/sL * sT^2)[[1]],((Acceleration[Point[carpus,2]]/.sol/.{T->tEval})/sL * sT^2)[[2]]*)
(*};*)
(*Export[StringJoin[currPath, "/carpusP2.mat"],carp2Kine,"MAT"];*)


(* ::Input:: *)
(*(* P1 on ground *)*)
(*gnd1Kine=*)
(*{((Location[Point[ground,2]]/.sol/.{T->tEval})/sL)[[1]],((Location[Point[ground,2]]/.sol/.{T->tEval})/sL)[[2]],*)
(*((Velocity[Point[ground,2]]/.sol/.{T->tEval})/sL * sT)[[1]],((Velocity[Point[ground,2]]/.sol/.{T->tEval})/sL * sT)[[2]],*)
(*((Acceleration[Point[ground,2]]/.sol/.{T->tEval})/sL * sT^2)[[1]],((Acceleration[Point[ground,2]]/.sol/.{T->tEval})/sL * sT^2)[[2]]*)
(*};*)
(*Export[StringJoin[currPath, "/groundP1.mat"],gnd1Kine,"MAT"];*)


(* ::Input:: *)
(*(* P1 on mV *)*)
(*mV1Kine=*)
(*{((Location[Point[mV,1]]/.sol/.{T->tEval})/sL)[[1]],((Location[Point[mV,1]]/.sol/.{T->tEval})/sL)[[2]],*)
(*((Velocity[Point[mV,1]]/.sol/.{T->tEval})/sL * sT)[[1]],((Velocity[Point[mV,1]]/.sol/.{T->tEval})/sL * sT)[[2]],*)
(*((Acceleration[Point[mV,1]]/.sol/.{T->tEval})/sL * sT^2)[[1]],((Acceleration[Point[mV,1]]/.sol/.{T->tEval})/sL * sT^2)[[2]]*)
(*};*)
(*Export[StringJoin[currPath, "/mVP1.mat"],mV1Kine,"MAT"];*)


(* ::Input:: *)
(*(* P1 on dactyl *)*)
(*dac1Kine=*)
(*{((Location[Point[dactyl,1]]/.sol/.{T->tEval})/sL)[[1]],((Location[Point[dactyl,1]]/.sol/.{T->tEval})/sL)[[2]],*)
(*((Velocity[Point[dactyl,1]]/.sol/.{T->tEval})/sL * sT)[[1]],((Velocity[Point[dactyl,1]]/.sol/.{T->tEval})/sL * sT)[[2]],*)
(*((Acceleration[Point[dactyl,1]]/.sol/.{T->tEval})/sL * sT^2)[[1]],((Acceleration[Point[dactyl,1]]/.sol/.{T->tEval})/sL * sT^2)[[2]]*)
(*};*)
(*Export[StringJoin[currPath, "/dactylP1.mat"],dac1Kine,"MAT"];*)
