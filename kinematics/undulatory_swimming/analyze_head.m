function analyze_head(vid_dir,visData,use_centroid)
% Performs kinematic analysis to test Lighthill's (1993) theory.  The data
% are assumed to be generated by head_tracker.m or fabricated data made by
% create_data


%% Parameters

if nargin < 2
    visData = 1;
end

if nargin < 3
    use_centroid = 1; % Use the centroid of the head or posterior mean
end

cutfreq = 30;   % Low-pass filter cutoff freq (Hz)
fMax    = 10;   % Maximum freq considered for the beat freq

% For calculating dp on head
b          = 0.44 * 10^-2; % One-half of the head mean head width (m)
rho        = 998;       % Density of water (kg/m^3)
con_factor = 10^-2;     % Conversion factor for linear dimensions (cm to m)
k          = .78;       % Numerical constant from Lighthill
k1         = .39;       % Another numerical constant from Lighthill

%% Establish path to be analyzed

% Prompt for dir, if none given
if nargin<1
    vid_dir = uigetdir(pwd,'Pick directory with data file');
end

% Define parent and sequence directories
iSep        = max(find(vid_dir(1:end-1) == filesep));
parent_dir  = vid_dir(1:iSep-1);
seq_dir     = vid_dir(iSep+1:end);

clear iSep

%% Load coordinate and parameter files

% seq_params.mat stores the 'p' structure, information about the movie
if ~isfile('seq_params.mat',vid_dir)
    error('seq_params file missing');
else
    load([vid_dir filesep 'seq_params'])
end

% coord_data.mat stores the 'd' structure, which has coordinate data 
if ~isfile('coord_data.mat',vid_dir) && ~isfile('coord_data_posterior.mat',vid_dir) 
    error('coord_data file missing');
elseif use_centroid
    load([vid_dir filesep 'coord_data'])
else
    load([vid_dir filesep 'coord_data_posterior'])
end

%% Determine freestream flow from motor settings

% Check units
if ~strcmp(p.units,'cm')
    warning(['The analysis is assuming the units are in cm, '...
        'but you are using ' p.units]);  
end

% use calibration to set U_inf
if ~isfield(p,'motorset')    
    U_inf = 0;  
    warning('No motorsetting given, assuming U_i_n_f = 0');
elseif p.motorset==35
    U_inf = 4.5; %cm/s
elseif p.motorset==40
    U_inf = 11; %cm/s
elseif p.motorset==45
    U_inf = 22; %cm/s
end 

%% Define coordinate and time vectors from d & p

% Convert to units
if size(d.xTip,2)>size(d.xTip,1)
    error('data should be arranged as a column vector');
end
xT = p.calconst .* d.xTip;
yT = p.calconst .* d.yTip;
xC = p.calconst .* d.xCtr;
yC = p.calconst .* d.yCtr;

% Time vector
%str2num(d.filename{1}(25:30))==d.framenum(1)

time        = d.framenum .* (1./p.framerate);
framerate   = p.framerate;
units       = p.units;

clear d p

%=====================================================================
%% Initiate interactive code, if 'analyzed_data' not present
%=====================================================================

prevAnalysis = ~isempty(dir([vid_dir filesep 'analyzed_data.mat']));

% Load previous 'm' data
if prevAnalysis
    disp('Loading analyzed_data.mat')
    load([vid_dir filesep 'analyzed_data.mat'])
end 

%% Filter coordinate data & calculate alpha

% Low-pass filter coordinate data
xT_f = butterworth(xT,framerate,cutfreq,'low');
yT_f = butterworth(yT,framerate,cutfreq,'low');
xC_f = butterworth(xC,framerate,cutfreq,'low');
yC_f = butterworth(yC,framerate,cutfreq,'low');

% Calculate alpha (after fliping to first and fourth quadrants)
xTmp  = -(xT_f-xC_f);
yTmp  = (yT_f-yC_f);   
alpha = atan2(yTmp,xTmp);

clear xTmp yTmp

%% Select best duration to analyze

if ~prevAnalysis
    figure;
    subplot(2,1,1)
    plot(time,alpha,'k-')
    grid on;
    subplot(2,1,2)
    duration = chooseDuration(time,yC_f);
    close

    % Find indices in time vector
    iDuration = [find(time>duration(1),1,'first'): ...
        find(time<duration(2),1,'last')];
    
else
    iDuration = [find(time>=m.time(1),1,'first'): ...
        find(time<=m.time(end),1,'last')];

end

time  = time(iDuration);
xC_f  = xC_f(iDuration);
yC_f  = yC_f(iDuration);
alpha = alpha(iDuration);
    
clear duration iDuration

%% Remove low frequency drift in data

yC_ff    = butter_high(yC_f,framerate);
xC_ff    = butter_high(xC_f,framerate);
alpha_ff = butter_high(alpha,framerate);

clear xTmp yTmp

%% Use smoothing splines to calculate U, V, & omega

% Here are approximate tolerences to be used in this section
tol_Y     = 1.e-3;  
tol_alpha = 1.e-3;

% Find smoothing spline for y
sp_y    = spaps(time',yC_ff',tol_Y);
sp_yDot = fnder(sp_y);

% Find smoothing spline for x
sp_x    = spaps(time',xC_ff',tol_Y);
sp_xDot = fnder(sp_x);

% Find smoothing spline for alpha
sp_alpha  = spaps(time',alpha_ff',tol_alpha);

% Solve for V & U
U = fnval(sp_xDot,time) + fnval(sp_alpha,time).*fnval(sp_yDot,time) ...
    + U_inf;
V = fnval(sp_yDot,time) + fnval(sp_alpha,time).*fnval(sp_xDot,time);

%% Interactively acquire peaks and troughs of V and alpha
% Chooses a duration (=seqDur) in the middle of the sequence

if ~prevAnalysis
    [vPk_T,vPk_Y] = choosePeaks(time,V,'Y');
    [aPk_T,aPk_Y] = choosePeaks(time,alpha_ff,'alpha');

    clear tT seqDur iTemp vTemp atemp tTemp
    
else
    vPk_T = m.vPk_T;
    vPk_Y = m.vPk_Y;
    aPk_T = m.aPk_T;
    aPk_Y = m.aPk_Y;
end

%% Save data for the analysis

m.time      = time;
m.xC_f      = xC_f;
m.yC_f      = yC_f;
m.xC_ff     = xC_ff;
m.yC_ff     = yC_ff;
m.alpha     = alpha;
m.alpha_ff  = alpha_ff;
m.vPk_T     = vPk_T;
m.vPk_Y     = vPk_Y;
m.aPk_T     = aPk_T;
m.aPk_Y     = aPk_Y;
m.V         = V;
m.U         = U;

if ~use_centroid
    save([vid_dir filesep 'analyzed_data_posterior'],'m')
else
    save([vid_dir filesep 'analyzed_data'],'m')
end

clear time xC_f yC_f alpha alpha_ff yPk_T yPk_Y aPk_T aPk_Y m xC xC_ff
clear yT yT_fxT xT_f xC yC aTemp xT yC_ff yT_f tol_Y tol_alpha



% ========================================================================

%% ================ Calculate final parameters ===========================
% ========================================================================
% Use analyzed_data to calculate the amplitude and phase relationship btwn
% V and alpha

%% Load analyzed_data.mat, define variables

% analyzed_data.mat stores the 'm' structure which has variables determined
% from the raw coordinate data in the 'd' structure
if ~use_centroid
    load([vid_dir filesep 'analyzed_data_posterior.mat'])
else
    load([vid_dir filesep 'analyzed_data.mat'])
end

% Redefine time as the selected period
time      = m.time;

% Center points after low-pass filter
xC_f      = m.xC_f;
yC_f      = m.yC_f;

% Alpha after low pass and high-pass filter respectively
xC_ff     = m.xC_ff;
yC_ff     = m.yC_ff;
alpha     = m.alpha;
alpha_ff  = m.alpha_ff;

% % V and U calculated from coordinates after both filters
% V         = m.V;
% U         = m.U;

% Manually-selected peaks and troughs 
vPk_T     = m.vPk_T;
vPk_Y     = m.vPk_Y;
aPk_T     = m.aPk_T;
aPk_Y     = m.aPk_Y;

clear m

%% Specify image files focused on in the analysis
% This generates a mat file that is used to focus any additional analysis
% on the best sequence of frames
% 
% tmp = dir([vid_dir filesep 'best_frames.mat']);
% 
% if isempty(tmp)
%     
%     % seq_params.mat stores the 'p' structure, information about the movie
%     tmp = dir([vid_dir filesep 'seq_params.mat']);
%     if isempty(tmp)
%         error('seq_params file missing');
%     else
%         load([vid_dir filesep 'seq_params'])
%     end
%     
%     % Define first part of filename
%     strdigs = '00000';
%     frNums = time.*p.framerate;
%     preName = p.fname(1:end-4-length(strdigs));
%     
%     % Loop through frame numbers to define filenames
%     for i = 1:length(frNums)
%         numStr = [strdigs num2str(frNums(i))];
%         bst(i).frame_num = frNums(i);
%         bst(i).fname     = [preName numStr(end-length(strdigs)+1:end) '.tif'];
%         
%         clear numStr
%     end
%     
%     save([vid_dir filesep 'best_frames'],'bst');
%     clear p tmp frNums strdigs bst
%     
% end


%% Use a new smoothing spline to calculate U, V, & alpha

% Here are approximate tolerences to be used in this section
tol_Y     = 1.e-6;  
tol_X     = 1.e-6;
tol_alpha = 1.e-6;

% Find smoothing spline for y
sp_y    = spaps(time',yC_ff',tol_Y);
sp_yDot = fnder(sp_y);

% Find smoothing spline for x
sp_x    = spaps(time',xC_ff',tol_X);
sp_xDot = fnder(sp_x);

% Find smoothing spline for alpha
sp_alpha  = spaps(time',alpha_ff',tol_alpha);
sp_omega  = fnder(sp_alpha);
spD_omega = fnder(sp_omega);

% Solve for V & U
U = fnval(sp_xDot,time) + fnval(sp_alpha,time).*fnval(sp_yDot,time) ...
    + U_inf;
V = fnval(sp_yDot,time) + fnval(sp_alpha,time).*fnval(sp_xDot,time);

% Find the first derivative of V
sp_V    = spaps(time',V',tol_Y);
sp_VDot = fnder(sp_V);
V_prime = fnval(sp_VDot,time);
 
% Solve for omega (i.e. alpha_prime)
alpha_prime = fnval(sp_omega,time);


%% Visualize splines

if visData
    figure
    
    subplot(3,1,1)
        h = plot(time,yC_ff,'.');
        set(h,'Color',.5'*[1 1 1]);
        hold on
        plot(time,fnval(sp_y,time),'r')
        ylabel('y')
        title(['Smoothing spline: tol Y = ' num2str(tol_Y) ...
              '  tol alpha = ' num2str(tol_alpha)]);
        grid on
        
    subplot(3,1,2)
        h = plot(time,xC_ff,'.');
        set(h,'Color',.5'*[1 1 1]);
        hold on
        plot(time,fnval(sp_x,time),'r')
        ylabel('x')
        grid on
        
    subplot(3,1,3)
        h = plot(time,alpha_ff.*(180/pi),'.');
        set(h,'Color',.5'*[1 1 1]);
        hold on
        plot(time,fnval(sp_alpha,time).*(180/pi),'r')
        ylabel('alpha')   
        xlabel('time (s)')
        grid on
end


%% Estimate the amplitude and phase of V and alpha

est_tbf  = mean([1/(2*mean([mean(diff(vPk_T)) mean(diff(vPk_T))])) ...
                 1/(2*mean([mean(diff(aPk_T)) mean(diff(aPk_T))]))]);
v_amp = mean(abs(diff(vPk_Y)))/2;
a_amp = mean(abs(diff(aPk_Y)))/2;

% Calculate phase of each peak & trough in Y
tau      = 1/est_tbf/2;  % Half the cycle period
stTime   = tau.*floor(min([aPk_T(1) vPk_T(1)])./tau); % Start time 

% Calculate the shift of each point, in terms of tau (cycle period)
half_phase_V = (vPk_T-stTime)./tau-floor((vPk_T-stTime)./tau);
half_phase_a = (aPk_T-stTime)./tau-floor((aPk_T-stTime)./tau);

% Convert into radians (tau => pi cycles), calc mean
est_phase_V = 2*pi.*mean(half_phase_V) + pi/4;
est_phase_a = 2*pi.*mean(half_phase_a) + pi/4;

clear half_phase_Y half_phase_a
clear tau stTime yPk_T yPk_Y aPk_T aPk_Y


%% Normalize amplitude and find frequency & phase for V, then alpha

% V_tmp has the amplitude normalized, for the curve fit
V_tmp    = (V-mean(V))./(1.4*std(V));
beta_est = [est_tbf est_phase_V];
beta     = nlinfit(time,V_tmp,@sin_tbf,beta_est);
tbf      = beta(1);
V_ph     = beta(2);

% Correct phase, if over one cycle
V_ph     = (V_ph/abs(V_ph))*2*pi*...
           (abs(V_ph)/(2*pi)-floor(abs(V_ph)/(2*pi)));
       
% Change into a positive phase
if V_ph < 0
    V_ph = 2*pi + V_ph;
end

clear beta V_tmp beta_est

global tbf_n
tbf_n = tbf;

alpha_tmp    = (alpha_ff-mean(alpha_ff))./(1.4*std(alpha_ff));
beta_est     = est_phase_a;
alpha_ph     = nlinfit(time,alpha_ff,@sin_phs,beta_est);
%tbf          = beta(1);
%alpha_ph     = beta(2);

% Correct phase, if over one cycle
alpha_ph     = (alpha_ph/abs(alpha_ph))*2*pi*...
               (abs(alpha_ph)/(2*pi)-floor(abs(alpha_ph)/(2*pi)));
           
% Change into a positive phase
if alpha_ph < 0
    alpha_ph = 2*pi + alpha_ph;
end

clear beta alpha_tmp beta_est


%% Nonlinear curve fit to find amplitude of sine wave

% Use freq of alpha as the beat frequency
global tbf_n phs_n
tbf_n = tbf;

% Find amplitude of V
phs_n     = V_ph;
V_amp     = nlinfit(time,V,@sin_amp,v_amp);

% Find amplitude of alpha
phs_n     = alpha_ph;
alpha_amp = nlinfit(time,alpha_ff,@sin_amp,a_amp);

clear tbf_n phs_n

% Evaluate values for sine waves
Vs          = mySin(time,V_amp,tbf,V_ph);
alphas      = mySin(time,alpha_amp,tbf,alpha_ph);
Vs_prime    = mySin_prime(time,V_amp,tbf,V_ph);
alphas_prime= mySin_prime(time,alpha_amp,tbf,alpha_ph);


%% Plot sine waves

if visData
    figure;
    subplot(4,1,1)
        h = plot(time,V,'-');
        hold on
        plot(time,Vs,'r-')
        set(h,'Color',.5'*[1 1 1]);
        hold off
        ylabel('V')
        grid on
%        title(['mean(U) = ' num2str(mean(U)) '   alpha_amp*U/V_amp = ' num2str(a_amp*mean(U)/v_amp)])
    subplot(4,1,2)
        h = plot(time,alpha_ff,'-');
        hold on
        plot(time,alphas,'r-')
        set(h,'Color',.5'*[1 1 1]);
        hold off
        ylabel('alpha')
        xlabel('time')
        grid on
   subplot(4,1,3)
        h = plot(time,V_prime,'-');
        hold on
        plot(time,Vs_prime,'r-')
        set(h,'Color',.5'*[1 1 1]);
        hold off
        ylabel('V prime')
        grid on
%        title(['mean(U) = ' num2str(mean(U)) '   alpha_amp*U/V_amp = ' num2str(a_amp*mean(U)/v_amp)])
    subplot(4,1,4)
        h = plot(time,alpha_prime,'-');
        hold on
        plot(time,alphas_prime,'r-')
        set(h,'Color',.5'*[1 1 1]);
        hold off
        ylabel('alpha prime')
        xlabel('time')
        grid on
end

%% Calculate phase shift

if (alpha_ph-V_ph) > pi
    phase_shift = -(2*pi - alpha_ph-V_ph); 
else
    phase_shift = alpha_ph-V_ph; 
end


%% Display sine wave data

if visData
    disp(' ');
    disp(' ');
    disp('KINEMATIC PARAMETERS ========================')
    disp(' ')
    disp(['tbf =                 ' num2str(tbf)])
    disp(['Amplitude of V =      ' num2str(V_amp)])
    disp(['Amplitude of alpha =  ' num2str(alpha_amp)])
    disp(['Phase shift (rad) =   ' num2str(phase_shift)])
    disp(' ')
end

%% Calculate pressure differences on the head from splines

% Pressure differences calculated from spline-fitted data
dp_trans_sp = 2.*b.*(1+k).*rho.*V_prime.*con_factor;
dp_rot_sp   = -2.*b.*(k+k1).*rho.*U.*alpha_prime.*con_factor;
dp_rot_sp_c = -2.*b.*(k+k1).*rho.*mean(U).*alpha_prime.*con_factor;
dp_tot_sp   = dp_trans_sp + dp_rot_sp_c;

% Pressure differences from sine waves
dp_trans_sn = 2.*b.*(1+k).*rho.*Vs_prime.*con_factor;
dp_rot_sn   = -2.*b.*(k+k1).*rho.*mean(U).*...
                alphas_prime.*con_factor;
dp_tot_sn   = dp_trans_sn + dp_rot_sn;

% Ampltude of different soruces of dp
dp_trans_amp = abs(2.*b.*(1+k).*rho.*2*pi*tbf*V_amp.*con_factor);
dp_rot_amp   = abs(-2.*b.*(k+k1).*rho.*mean(U).*...
                2*pi*tbf*alpha_amp.*con_factor);
            
dp_tot_amp   = 0.5.*range([dp_rot_sn + dp_trans_sn]);            

K_ratio_sn  = V_amp./(mean(U).*alpha_amp);
K_ratio_sn_mean = mean(Vs./(U./alphas_prime));

if visData
    figure;
    subplot(2,1,1)
    plot(time,dp_trans_sp,'b-',time,dp_rot_sp,'g',time,dp_rot_sp_c,'b--',...
        time, dp_tot_sp,'r--')
    legend('translation','rotation','rot (U_inf)','total')
    xlabel('time (s)');ylabel('dp (Pa)');title('Spline data')
    grid on

    subplot(2,1,2)
    plot(time,dp_trans_sn,'b-',time,dp_rot_sn,'g',...
        time, dp_tot_sn,'r--')
    xlabel('time (s)');ylabel('dp (Pa)');title('Sine wave data')
    grid on
end


%% Store data

snData.tbf          = tbf;
snData.V_amp        = V_amp;
snData.alpha_amp    = alpha_amp;
snData.V_ph         = V_ph;
snData.alpha_ph     = alpha_ph;
snData.ph_shift     = phase_shift;
snData.time         = time;
snData.V            = mySin(time,V_amp,tbf,V_ph);
snData.alpha        = mySin(time,alpha_amp,tbf,alpha_ph);
snData.V_prime      = mySin_prime(time,V_amp,tbf,V_ph);
snData.alpha_prime  = mySin(time,alpha_amp,tbf,alpha_ph);
snData.U            = U;
snData.dp_trans     = dp_trans_sn;
snData.dp_rot       = dp_rot_sn;
snData.dp_tot       = dp_tot_sn;
snData.dp_trans_amp = dp_trans_amp;
snData.dp_rot_amp   = dp_rot_amp;
snData.dp_tot_amp   = dp_tot_amp;
snData.k_ratio      = K_ratio_sn;
snData.k_ratio_mean = K_ratio_sn_mean;

spData.time        = time;
spData.V           = V;
spData.alpha       = fnval(sp_alpha,time);
spData.V_prime     = V_prime;
spData.alpha_prime = alpha_prime;
spData.dp_trans    = dp_trans_sp;
spData.dp_rot      = dp_rot_sp;
spData.dp_tot      = dp_tot_sp;

if ~use_centroid
    save([vid_dir filesep 'periodic_data_posterior'],'snData')
    save([vid_dir filesep 'spline_data_posterior'],'spData')
else
    save([vid_dir filesep 'periodic_data'],'snData')
    save([vid_dir filesep 'spline_data'],'spData')
end
%disp(' '); disp(['Saved   ' vid_dir filesep 'periodic_data.mat']);


%% 


return


% =========================================================================
%% FUNCTIONS
% =========================================================================


function x = mySin(t,amp,tbf,phs)
x = amp .* sin(2*pi*tbf.*t + phs);

function x = mySin_prime(t,amp,tbf,phs)
x = 2*pi*tbf*amp .* cos(2*pi*tbf.*t + phs);

function x = sin_amp(amp,t)
global phs_n tbf_n
x = amp .* sin(2*pi*tbf_n.*t + phs_n);

function x = sin_phs(beta,t)
% Normalize data before using this with nlinfit
global tbf_n
phs = beta(1);
x = sin(2*pi*tbf_n.*t + phs);


function x = sin_tbf(beta,t)
% Normalize data before using this with nlinfit
tbf = beta(1);
phs = beta(2);
x = sin(2*pi*tbf.*t + phs);


function data_filtered = butterworth(data,sample_rate,cutfreq,type)
%Returns data filtered by a butterworth filter
%  data - vector of data for filtering
%  sample_rate - rate of sampling for data (must have equivalent intervals)
%  cutfreq - cut off frequency (must be 2 values for bandstop)
%  type - 'low' for lowpass (default), 'high' for highpass, 'stop' for bandstop

if nargin < 4
    type = 'low';
end

if strcmp(type,'stop') && ~(length(cutfreq)==2)
    error('Stop pass must have a two-element cutfreq')
end 

ff              = cutfreq./(sample_rate./2);
[B A]           = butter(2,ff,type);
data_filtered   = filtfilt(B,A,data);     % Filtered data


function data_filtered = butter_high(data,sample_rate)    
% All frequency values are in Hz.
Fs = sample_rate;   % Sampling Frequency

Fstop = .3;  % Stopband Frequency
Fpass = 2;   % Passband Frequency
Astop = 60;  % Stopband Attenuation (dB)
Apass = 1;   % Passband Ripple (dB)

% Calculate the order from the parameters using BUTTORD.
[N,Fc] = buttord(Fpass/(Fs/2), Fstop/(Fs/2), Apass, Astop);

% Calculate the zpk values using the BUTTER function.
[B A] = butter(N, Fc, 'high');

data_filtered   = filtfilt(B,A,data); 


function yes = isfile(fname,dirname)
% Checks if file is present in given directory
a = dir(dirname);
yes = 0;
for i = 3:length(a)
    if strcmp(a(i).name,fname)
        yes = 1;
        return
    end
end


function [pk_t,pk_y] = choosePeaks(xData,yData,ytxt)
%Used for finding coordinate points on a static image 'img'.

figure
set(gcf,'DoubleBuffer','on');

txt = 'Peaks(+) & troughs(o): do not skip any & start w/1st peak';

plot(xData,yData,'k')
grid on
title(txt)
ylabel(ytxt)

hold on;

disp(' '); disp(' ');
disp('Left mouse button picks points.');disp(' ');
disp('Right mouse button removes last point.');disp(' ');
disp('Press return to stop.')
%disp('Z = zoom');


n = 0;
but = 1;

while 1 == 1
    
    [xi,yi,but] = ginput(1);
    
    if isempty(but) % Return
        
        if isempty(x)
            warning('You need to select coordinates')
        else
            break
        end
        
    elseif but==1 % Left click
        
        n    = n+1;
        x(n) = xi;
        y(n) = yi;

    elseif but==3 % Right click
        
        n    = max([0 n-1]);

        if n==0
            x = [];
            y = [];
        else
            x = x(1:n);
            y = y(1:n);            
        end
       
    end
    
    % Vary symbol depending on odd or even number
    if n>0 && (n/2==floor(n/2))
        symb{n} = 'or';
    else
        symb{n} = '+r';
    end
    
    % Plot
    hold off
    plot(xData,yData,'k')
    grid on
    title(txt)
    ylabel(ytxt)
    hold on
    
    if n>0
        for j=1:n
            plot(x(j),y(j),symb{j})
        end
    end
    
end

close
pk_t = x;
pk_y = y;




function duration = chooseDuration(xData,yData)
%Used for finding coordinate points on a static image 'img'.

set(gcf,'DoubleBuffer','on');

txt = 'Choose duration to analyze (2 points)';
ytxt = 'y';

plot(xData,yData,'k')
grid on
title(txt)
ylabel(ytxt)

hold on;
set(gcf,'DoubleBuffer','on');
disp(' '); disp(' ');
disp('Left mouse button picks points.');disp(' ');
disp('Right mouse button removes last point.');disp(' ');
disp('Press return to stop.')
%disp('Z = zoom');


n = 0;
but = 1;

while 1 == 1
    
    [xi,yi,but] = ginput(1);
    
    if isempty(but) % Return
        
        if length(x)~=2
            warning('You need to select 2 coordinates')
        else
            break
        end
        
    elseif but==1 % Left click
        
        n    = min([2 n+1]);
        x(n) = xi;
        y(n) = yi;

    elseif but==3 % Right click
        
        n    = max([0 n-1]);

        if n==0
            x = [];
            y = [];
        elseif n==1
            x = x(1);
            y = y(1);            
        end
        
    end
    
    hold off
    plot(xData,yData,'k')
    grid on
    title(txt)
    ylabel(ytxt)
    hold on
    
    if length(x)==1
        plot(x,y,'r+')
    elseif length(x)==2
        plot([x(1) x(2) x(2) x(1) x(1)],[y(2) y(2) y(1) y(1) y(2)],'r-')
    end
    
end

duration = [min(x) max(x)];



