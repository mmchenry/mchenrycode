(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* ::Section:: *)
(*Define parameter values (instead of importing)*)


(* ::Input:: *)
(*ClearMech[];ClearAll["Global`*"]; Needs["MechanicalSystems`Modeler2D`"];Off[General::"spell"];Off[General::"spelll"];*)


(* ::Text:: *)
(**)
(**)
(*Linkage lengths (SI units)*)


(* ::Input:: *)
(*L1In=5.26 *10^-3;*)
(*L2In=2.2 *10^-3;*)
(*L3In=.81*10^-3;*)
(*L4In=4.8 *10^-3;*)
(*EXLocalIn = 1.43 *10^-3 ;*)
(*EYLocalIn = 1.64 *10^-3 ;*)
(*FXLocalIn = 5.52 *10^-3 ;*)
(*FYLocalIn = 4.3 *10^-3;*)


(* ::Text:: *)
(**)
(*Dactyl/propdus mass*)


(* ::Input:: *)
(*dMassIn = 4.53 *10^-4;*)


(* ::Text:: *)
(**)
(*Dactyl/propdus moment of inertia*)


(* ::Input:: *)
(*dIIn= 8.16 *10^-8 ; (* (kg m^2) *)*)
(*waterIIn = 1*10^-8;(* (kg m^2) *)*)


(* ::Text:: *)
(**)
(**)
(*Spring at the mV joint (linear spring stiffness (N/m) * L2^2 (approx. distance to force application)*)


(* ::Input:: *)
(*kSpringIn =0.1 (60*10^3) (3.18 *10^-3)^2;    (* Torsion spring stiffness (Nm/rad) *)*)
(**)


(* ::Text:: *)
(*Max torque estimated as max force (29 N in Zack et al paper), times L2 (3.18e-3, approximate distance to force application) *)


(* ::Input:: *)
(*thetaRestIn =  ((90-70)/180) N[\[Pi]];*)


(* ::Text:: *)
(**)
(**)
(*Duration of simulation (s)*)


(* ::Input:: *)
(*simDurationIn = 8*10^-3;*)


(* ::Text:: *)
(**)
(**)
(*Initial input angle, \[Theta]in, at the mV joint*)


(* ::Input:: *)
(*thetaStartIn = ((90-35)/180) N[\[Pi]];*)


(* ::Input:: *)
(*dAIn=1.5 * 10^-11;*)
(*rhoIn=998;*)
(*CdIn = 0*1;*)


(* ::Text:: *)
(**)
(**)
(*Check that the geometry is possible (both should be 'True')*)


(* ::Input:: *)
(*mxErrIn = 10^-5;*)


(* ::Section::Closed:: *)
(*Import parameter values (instead of defining)*)


(* ::Subsection:: *)
(*Set parameters*)


(* ::Input:: *)
(*KillMech[];ClearMech[];ClearAll["Global`*"]; Needs["MechanicalSystems`Modeler2D`"];Off[General::"spell"];*)


(* ::Input:: *)
(*currPath = Import["/Volumes/Docs/Projects/Patek_project/pod_model/sims/curr_path.txt",{"Text","Lines"}];*)


(* ::Input:: *)
(*currPath*)


(* ::Input:: *)
(*inParams = Import[StringJoin[currPath, "/input_params.mat"]][[1]];*)


(* ::Input:: *)
(*tEvalIn = Import[StringJoin[currPath, "/eval_time.mat"]][[1]];*)


(* ::Input:: *)
(*L1In = inParams[[1]];*)
(*L2In=inParams[[2]];*)
(*L3In=inParams[[3]];*)
(*L4In=inParams[[4]];*)
(**)
(*EXLocalIn = inParams[[5]];*)
(*EYLocalIn=inParams[[6]];*)
(*FXLocalIn=inParams[[7]];*)
(*FYLocalIn=inParams[[8]];*)
(**)
(*thetaStartIn=inParams[[9]];*)
(*dMassIn=inParams[[10]];*)
(*dIIn=inParams[[11]];*)
(*kSpringIn=inParams[[12]];*)
(*thetaRestIn=inParams[[13]];*)
(**)
(*simDurationIn=inParams[[14]];*)
(*dAIn=inParams[[15]];*)
(*rhoIn=inParams[[16]];*)
(*CdIn=inParams[[17]];*)
(*waterIIn = inParams[[18]];*)
(*mxErrIn = inParams[[19]];*)


(* ::Input:: *)
(*Clear[inParams]*)


(* ::Section:: *)
(*Linkage model *)


(* ::Subsection:: *)
(*Rescale input parameter values*)


(* ::Text:: *)
(**)
(*Scale Factors (Mutliplers of all parameters -- helps with numerical instabilities)*)


(* ::Input:: *)
(*sL = 1 / L1In;*)
(*sM = 1/dMassIn;*)
(*sT=10^3;*)


(* ::Input:: *)
(*(* Apply scale factors to parameters *)*)
(*dMass = dMassIn sM;*)
(*dI= dIIn sM sL^2;*)
(*waterI=waterIIn sM sL^2;*)
(**)
(*L1=L1In sL;*)
(*L2=L2In sL;*)
(*L3=L3In sL;*)
(*L4=L4In  sL;*)
(**)
(*EXLocal = EXLocalIn sL;*)
(*EYLocal = EYLocalIn sL;*)
(*FXLocal = FXLocalIn sL;*)
(*FYLocal = FYLocalIn sL;*)
(*thetaStart    = thetaStartIn;*)
(**)
(*kSpring = kSpringIn (sM sL^2/sT^2);*)
(*thetaRest= thetaRestIn;*)
(*dA = dAIn * sL^5;*)
(*rho = rhoIn * sM / sL^3;*)
(*Cd = CdIn;*)
(**)
(*simDuration = simDurationIn * sT;*)
(*tEval = tEvalIn*sT;*)
(**)
(*mxErr = mxErrIn;*)


(* ::Input:: *)
(*Clear[dMassIn, dIIn,L1In,L2In,L3In,L4In,kSpringIn,TmaxIn,EXLocalIn,EYLocalIn,FXLocalIn,FYLocalIn,thetaIn,simDurationIn,tEvalIn,simDurationIn,tEvalIn,dAIn,rhoIn,CdIn,waterIIn,mxErrIn]*)


(* ::Subsection:: *)
(*Calculated parameter values, define model inputs*)


(* ::Text:: *)
(**)
(**)
(*Angle, \[Psi], btwn L1 & L4:*)


(* ::Input:: *)
(*(* This angle ?*)*)
(*si[theta_]:=ArcCos[(h[theta]^2+L1^2-L2^2)/(2 h[theta] L1)]+ArcCos[(h[theta]^2+L4^2-L3^2)/(2 h[theta] L4)];*)
(*(* Distance btwn D & B: *)*)
(*h[theta_]:=Sqrt[L1^2+L2^2-2 L1 L2 Cos[theta]];*)


(* ::Text:: *)
(**)
(**)
(*Check that the geometry is possible (both should be 'True')*)


(* ::Input:: *)
(*L4  < ( L3 + h[thetaStart])*)


(* ::Input:: *)
(*h[thetaStart]*)


(* ::Input:: *)
(*L3*)


(* ::Input:: *)
(*L4*)


(* ::Input:: *)
(*L4  > (  h[thetaStart]-L3)*)


(* ::Input:: *)
(*thetaStart*)


(* ::Text:: *)
(**)
(**)
(*Points on the appendage*)


(* ::Input:: *)
(*AX=0;*)
(*AY= 0;*)
(*BX=L2 Sin[thetaStart];*)
(*BY=L2 Cos[thetaStart];*)
(*CX=L4 Sin[si[thetaStart]];*)
(*CY=L1-L4 Cos[si[thetaStart]];*)
(*DX=0;*)
(*DY=L1;*)
(*EX =BX+ EXLocal;*)
(*EY=BY - EYLocal;*)
(*FX=BX- FXLocal;*)
(*FY=EY-FYLocal;*)


(* ::Input:: *)
(*Clear[si,h]*)


(* ::Text:: *)
(**)
(**)
(*Body addresses*)


(* ::Input:: *)
(*ground = 1; mV = 2;carpus = 3;dactyl = 4;*)


(* ::Text:: *)
(**)
(**)
(*Display initial geometry*)


(* ::Input:: *)
(*offset = .09 L1;*)
(*Show[*)
(*ListPlot[{*)
(*{{AX,AY},{BX,BY}},*)
(*{{CX,CY},{DX,DY}},*)
(*{{BX,BY},{EX,EY},{CX,CY},{BX,BY}},*)
(*{{EX,EY},{FX,FY}}*)
(*},*)
(*PlotMarkers->Automatic,Joined->True,*)
(*Frame->True,AspectRatio->Automatic,*)
(*PlotLabel->"Initial geometry",*)
(*PlotRange->{{-1,1},{-1,1}}],*)
(*Graphics[*)
(*{Text["A",{AX-offset,AY+offset}],Text["B",{BX-offset,BY+offset}],*)
(*Text["C",{CX+offset,CY+offset}],Text["D",{DX-offset,DY+offset}],*)
(*Text["E",{EX+offset,EY-offset}],Text["F",{FX-offset,FY+offset}],*)
(*Text["L1",{Mean[{AX,DX}]-offset,Mean[{AY,DY}]}],*)
(*Text["L2",{Mean[{AX,BX}]-offset,Mean[{AY,BY}]}+offset],*)
(*Text["L3",{Mean[{CX,BX}]-offset,Mean[{CY,BY}]}+offset/2],*)
(*Text["L4",{Mean[{DX,CX}]-offset,Mean[{DY,CY}]}+offset]*)
(*}]*)
(*]*)


(* ::Subsection:: *)
(*Define Bodies*)


(* ::Input:: *)
(*bd[ground] = Body[ground,*)
(*PointList->{*)
(*(*P1*){DX,DY}},*)
(*InitialGuess->{*)
(*{0,0},0}*)
(*];*)


(* ::Input:: *)
(*bd[mV] = Body[mV,*)
(*PointList->{*)
(*(*P1*){BX,BY}},*)
(*Centroid->{0,0},*)
(*InitialGuess->{*)
(*{0,0},0}*)
(*];*)


(* ::Input:: *)
(*bd[carpus] = Body[carpus,*)
(*   PointList -> {*)
(*     (*P1*){ CX - BX, CY - BY},*)
(*     (*P2*){ EX - BX, EY - BY}},*)
(*Centroid->{0,0},*)
(*         InitialGuess -> {*)
(*               {BX, BY}, 0}*)
(*         ];*)


(* ::Input:: *)
(*bd[dactyl] = Body[dactyl,*)
(*      PointList -> {*)
(*          (*P1*){FX - EX, FX - EX}},*)
(*Mass ->dMass,*)
(*Inertia ->dI+waterI,*)
(*Centroid->{0,0},*)
(*      InitialGuess -> {*)
(*         {EX, EY}, 0}*)
(*      ];*)


(* ::Input:: *)
(*SetBodies[bd[ground],bd[mV],bd[carpus],bd[dactyl]];*)


(* ::Subsection:: *)
(*Define constraints*)


(* ::Text:: *)
(**)
(*Pin joint between ground and mV:*)


(* ::Input:: *)
(*cs[1]= Revolute2[1,Point[ground,0],Point[mV,0]];*)


(* ::Text:: *)
(**)
(*Initially fix position of joint at mV origin (removed later):*)


(* ::Input:: *)
(*cs[2] = RotationLock1[2,  mV,0];*)


(* ::Text:: *)
(**)
(*Pin joint between carpus and mV:*)


(* ::Input:: *)
(*cs[3] = Revolute2[3, Point[carpus, 0], Point[mV, 1]];*)


(* ::Text:: *)
(**)
(*Fix distance between ground and top of carpus:*)


(* ::Input:: *)
(*cs[4] = RelativeDistance1[4, Point[carpus, 1], Point[ground, 1], L4];*)


(* ::Text:: *)
(**)
(*Pin btwn carpus and dactyl*)


(* ::Input:: *)
(*cs[5] = Revolute2[5, Point[dactyl, 0], Point[carpus, 2]];*)


(* ::Text:: *)
(**)
(*Lock rotation btwn carpus & dactyl*)


(* ::Input:: *)
(*cs[6] = RotationLock1[6, carpus, dactyl, 0];*)


(* ::Input:: *)
(*SetConstraints[cs[1], cs[2], cs[3], cs[4],cs[5],cs[6]];*)


(* ::Input:: *)
(*Print["Check system after constraints:" Evaluate[CheckSystem[]]]*)


(* ::Subsection::Closed:: *)
(*Evaluate kinematic model*)


(* ::Text:: *)
(*SetParameters[{*)
(*   (*Torsion spring stiffness*)  theta -> \[Theta]*)
(*   }];*)


(* ::Input:: *)
(*graph=Graphics[{*)
(*(*ground*){RGBColor[0,0,1],Bar[Axis[ground,0,1],10^-4 sL,10^-4 sL]},*)
(*(*mV*){RGBColor[0,.5,.5],Bar[Line[mV,0,1],10^-4 sL,10^-4 sL]},*)
(*(*carpus*){RGBColor[1,0,0],Bar[Line[carpus,0,1],10^-4 sL,10^-4 sL]},*)
(*(*dactyl*){RGBColor[0,1,0],Bar[Line[dactyl,0,1],10^-4 sL,10^-4 sL]}*)
(*},*)
(*Frame->True,*)
(*AspectRatio->Automatic,*)
(*GridLines->Automatic,*)
(*PlotRange->{{-1,1.5},{-2,1}}*)
(*];*)
(**)
(*Show[graph/.SolveMech[]]*)


(* ::Input:: *)
(*Evaluate[{Angle[mV,1]}/.SolveMech[]] (180/\[Pi])*)


(* ::Subsection:: *)
(*Define Loads*)


(* ::Text:: *)
(**)
(*Moment created by the spring*)


(* ::Input:: *)
(*springMoment=-kSpring  ( Angle[mV,1]-thetaRest);*)
(*dragMoment=(-0.5*rho*Cd*(Velocity[dactyl][[3]])^2*dA) (Velocity[dactyl][[3]]/Abs[10^-20+Velocity[dactyl][[3]]]);*)


(* ::Input:: *)
(*ld[1]=Moment[mV,springMoment];*)


(* ::Text:: *)
(**)
(*Drag on dactyl*)


(* ::Text:: *)
(*ld[2] = Force[dactyl, Axis[Point[dactyl, 1], -Velocity[dactyl, 1]^2], 5.0, Magnitude -> Relative];*)


(* ::Input:: *)
(*ld[2]=Moment[dactyl,0*dragMoment];*)


(* ::Text:: *)
(*TODO: Add Acceleration reaction on dactyl*)


(* ::Input:: *)
(*ld[3]=Gravity[{0,-1},0];*)


(* ::Input:: *)
(*SetLoads[ld[1],ld[2]]*)


(* ::Input:: *)
(*Print["Check system after loads:" Evaluate[CheckSystem[]]]*)


(* ::Subsection:: *)
(*Find solution*)


(* ::Text:: *)
(*Solution with the 4-bar linkage constrained from moving:*)


(* ::Text:: *)
(*Remove constraint 2 (fixed angle of the mV)  & define initial conditions*)


(* ::Input:: *)
(*fsys = SetFree[2,{Solution->Dynamic,*)
(*InitialCondition->{T->0,\[CapitalTheta]2d->0,\[CapitalTheta]3d->0,\[CapitalTheta]4d->0,X2d->0,Y2d->0,X3d->0,Y3d->0,X4d->0,Y4d->0}}];*)


(* ::Text:: *)
(*SolveFree[fsys]*)


(* ::Input:: *)
(*(* Default solver *)*)
(*sol = SolveFree[fsys, simDuration, MakeRules -> {Location, Velocity, Acceleration},*)
(*MaxError->mxErr];*)


(* ::Text:: *)
(*(* High precision solver *)*)
(*sol = SolveFree[fsys, simDuration, MakeRules -> {Location, Velocity, Acceleration},*)
(*   ConstraintCorrection -> True,*)
(*   MaxError -> 10^-7,*)
(*   Method -> Corrector,*)
(*   FitDegree -> Quadratic,*)
(*   MaxSteps -> 5000];*)


(* ::Subsection::Closed:: *)
(*Simulation diagnostics (for debugging)*)


(* ::Input:: *)
(*Constraints[1]/.sol*)
(*Constraints[3]/.sol*)
(*Constraints[4]/.sol*)


(* ::Input:: *)
(*StepMech[]*)


(* ::Input:: *)
(*Loads[dactyl,Coordinates->Global][[2]]*)


(* ::Input:: *)
(*(Loads[carpus,Coordinates->Global])/.sol/.{T->tEval}*)


(* ::Subsection:: *)
(*Draw bodies*)


graph = Graphics[{
{RGBColor[0, 0, 1], Bar[Line[ground, 0, 1], sL/10^4, sL/10^4]}, 
{RGBColor[0, 0.5, 0.5], Bar[Line[mV, 0, 1], sL/10^4, sL/10^4]}, 
{RGBColor[1, 0, 0], Bar[Line[carpus, 0, 1], sL/10^4, sL/10^4]}, 
{RGBColor[0, 1, 0], Bar[Line[dactyl, 0, 1], sL/10^4, sL/10^4]}}, 
Frame -> True, AspectRatio -> Automatic, GridLines -> Automatic]; 


(* ::Input:: *)
(*Show[graph/.(sol/.{T->0*simDuration})]*)


(* ::Text:: *)
(*numPlot = 10; GraphicsGrid[{graph /. (sol /. Table[{T -> i}, {i, 0, simDuration, simDuration/numPlot}] )}]*)


(* ::Input:: *)
(*Animate[Show[graph /. (sol /. {T -> i})], {i, 0, simDuration, .1}]*)


(* ::Subsection:: *)
(*Graph results*)


(* ::Text:: *)
(**)
(*Theta (angle btwn mV and ground (L1))*)


(* ::Input:: *)
(*(180/Pi) Angle[mV,1]/.sol/.{T->0} *)


(* ::Input:: *)
(*thetaStart (180/Pi)*)


(* ::Input:: *)
(*thetaRest*)


(* ::Input:: *)
(*Plot[{(springMoment/.sol),T*0},{T,0,simDuration}]*)


(* ::Input:: *)
(*(180/Pi) Tmax/kSpring*)


(* ::Input:: *)
(*(* Moment on mV *)*)
(*Plot[(180/Pi)((Angle[mV,1])-(Pi/2-thetaRest))/.sol,{T,0,simDuration}]*)


(* ::Input:: *)
(*(180/Pi)thetaRest*)


(* ::Input:: *)
(*springMoment/.sol/.{T->0}*)


(* ::Input:: *)
(*(Pi/2-Angle[mV,1]-thetaRest)kSpring/.sol/.{T->0}*)


(* ::Input:: *)
(*(* Moment on mV *)*)
(*Plot[{(180/Pi)(Angle[mV,1])/.sol,0 T+(180/Pi) thetaRest},{T,0,simDuration}]*)


(* ::Input:: *)
(*(* Moment on mV *)*)
(*Plot[{(180/Pi)(Pi/2-Angle[mV,1]-thetaRest)/.sol,0 T},{T,0,simDuration}]*)


(* ::Input:: *)
(*Plot[Velocity[dactyl][[3]]/.sol,{T,0,simDuration}]*)


(* ::Input:: *)
(* *)


(* ::Subsection:: *)
(*Energetics*)


(* ::Text:: *)
(*springEnergy[T_] := -((Angle[mV, 1] - thetaRest)/Abs[(Angle[mV, 1] - thetaRest)]) 0.5 kSpring (Angle[mV, 1] - thetaRest)^2 ;*)


(* ::Input:: *)
(*springEnergy=Abs[0.5springMoment (Angle[mV,1]-thetaRest)/.sol];*)


(* ::Input:: *)
(*dacSpeed=Sqrt[*)
(*(Velocity[carpus,2][[1]])^2+(Velocity[carpus,2][[2]])^2]/.sol;*)


(* ::Text:: *)
(*dragEnergy[ti_] := NIntegrate[totDrag[t], {t, 0, ti}];*)


(* ::Input:: *)
(*kineEnergy=(*Rotation *)(0.5 (dI+waterI) Velocity[dactyl][[3]]^2  +*)
(*        (* Translation *) 0.5 dMass dacSpeed^2)/.sol;*)


(* ::Input:: *)
(*totEnergy = springEnergy  + kineEnergy;*)


(* ::Input:: *)
(*ListPlot[Table[{((180/Pi) (Pi/2-Angle[mV,1] -thetaRest)) /. sol, springMoment /. sol}, {T, simDuration/100, simDuration - simDuration/100, simDuration/100}]]*)


(* ::Input:: *)
(*kinePlot=Plot[kineEnergy,{T,0,simDuration},DisplayFunction->Identity,PlotStyle->RGBColor[1, 0,0]];*)
(*springPlot=Plot[springEnergy,{T,0,simDuration},DisplayFunction->Identity,PlotStyle->{RGBColor[0, 0,1]}];*)
(*totPlot=Plot[totEnergy,{T,0,simDuration},DisplayFunction->Identity,PlotStyle->{RGBColor[0, 0,0]}];*)
(**)
(*Show[springPlot,kinePlot,totPlot,DisplayFunction->$DisplayFunction]*)


(* ::Input:: *)
(*kinePlot=Plot[kineEnergy[All]/.sol,{T,0,simDuration},DisplayFunction->Identity,PlotStyle->RGBColor[1, 0,0]];*)
(*springPlot=Plot[springEnergy[T]/.sol,{T,0,simDuration},DisplayFunction->Identity,PlotStyle->{RGBColor[0, 0,1],Dashed}];*)
(*totPlot=Plot[(kineEnergy[T]+springEnergy[T])/.sol,{T,0,simDuration},DisplayFunction->Identity,PlotStyle->{RGBColor[0, 0,0]}];*)
(*Show[springPlot,kinePlot,totPlot,DisplayFunction->$DisplayFunction]*)


(* ::Input:: *)
(*springEnergy[T]/.sol/.{T->3}*)


(* ::Subsection:: *)
(*Export data*)


(* ::Input:: *)
(*(* P1 on carpus *)*)
(*carp1Kine=*)
(*{((Location[Point[carpus,1]]/.sol/.{T->tEval})/sL)[[1]],((Location[Point[carpus,1]]/.sol/.{T->tEval})/sL)[[2]],*)
(*((Velocity[Point[carpus,1]]/.sol/.{T->tEval})/sL * sT)[[1]],((Velocity[Point[carpus,1]]/.sol/.{T->tEval})/sL * sT)[[2]],*)
(*((Acceleration[Point[carpus,1]]/.sol/.{T->tEval})/sL * sT^2)[[1]],((Acceleration[Point[carpus,1]]/.sol/.{T->tEval})/sL * sT^2)[[2]]*)
(*};*)
(*Export[StringJoin[currPath, "/carpusP1.mat"],carp1Kine,"MAT"];*)


(* ::Input:: *)
(*(* P2 on carpus *)*)
(*carp2Kine=*)
(*{((Location[Point[carpus,2]]/.sol/.{T->tEval})/sL)[[1]],((Location[Point[carpus,2]]/.sol/.{T->tEval})/sL)[[2]],*)
(*((Velocity[Point[carpus,2]]/.sol/.{T->tEval})/sL * sT)[[1]],((Velocity[Point[carpus,2]]/.sol/.{T->tEval})/sL * sT)[[2]],*)
(*((Acceleration[Point[carpus,2]]/.sol/.{T->tEval})/sL * sT^2)[[1]],((Acceleration[Point[carpus,2]]/.sol/.{T->tEval})/sL * sT^2)[[2]]*)
(*};*)
(*Export[StringJoin[currPath, "/carpusP2.mat"],carp2Kine,"MAT"];*)


(* ::Input:: *)
(*(* P1 on ground *)*)
(*gnd1Kine=*)
(*{((Location[Point[ground,1]]/.sol/.{T->tEval})/sL)[[1]],((Location[Point[ground,1]]/.sol/.{T->tEval})/sL)[[2]],*)
(*((Velocity[Point[ground,1]]/.sol/.{T->tEval})/sL * sT)[[1]],((Velocity[Point[ground,1]]/.sol/.{T->tEval})/sL * sT)[[2]],*)
(*((Acceleration[Point[ground,1]]/.sol/.{T->tEval})/sL * sT^2)[[1]],((Acceleration[Point[ground,1]]/.sol/.{T->tEval})/sL * sT^2)[[2]]*)
(*};*)
(*Export[StringJoin[currPath, "/groundP1.mat"],gnd1Kine,"MAT"];*)


(* ::Input:: *)
(*(* P1 on mV *)*)
(*mV1Kine=*)
(*{((Location[Point[mV,1]]/.sol/.{T->tEval})/sL)[[1]],((Location[Point[mV,1]]/.sol/.{T->tEval})/sL)[[2]],*)
(*((Velocity[Point[mV,1]]/.sol/.{T->tEval})/sL * sT)[[1]],((Velocity[Point[mV,1]]/.sol/.{T->tEval})/sL * sT)[[2]],*)
(*((Acceleration[Point[mV,1]]/.sol/.{T->tEval})/sL * sT^2)[[1]],((Acceleration[Point[mV,1]]/.sol/.{T->tEval})/sL * sT^2)[[2]]*)
(*};*)
(*Export[StringJoin[currPath, "/mVP1.mat"],mV1Kine,"MAT"];*)


(* ::Input:: *)
(*(* P1 on dactyl *)*)
(*dac1Kine=*)
(*{((Location[Point[dactyl,1]]/.sol/.{T->tEval})/sL)[[1]],((Location[Point[dactyl,1]]/.sol/.{T->tEval})/sL)[[2]],*)
(*((Velocity[Point[dactyl,1]]/.sol/.{T->tEval})/sL * sT)[[1]],((Velocity[Point[dactyl,1]]/.sol/.{T->tEval})/sL * sT)[[2]],*)
(*((Acceleration[Point[dactyl,1]]/.sol/.{T->tEval})/sL * sT^2)[[1]],((Acceleration[Point[dactyl,1]]/.sol/.{T->tEval})/sL * sT^2)[[2]]*)
(*};*)
(*Export[StringJoin[currPath, "/dactylP1.mat"],dac1Kine,"MAT"];*)


(* ::Input:: *)
(*(* Moment from spring *)*)
(*springM = (springMoment*)
(*/.sol/.{T->tEval})/sM/sL^2*sT^2;*)
(*Export[StringJoin[currPath, "/springMoment.mat"],springM,"MAT"];*)


(* ::Input:: *)
(*(* Moment from drag *)*)
(*dragM = (dragMoment*)
(*/.sol/.{T->tEval}) /sM/sL^2*sT^2;*)
(*Export[StringJoin[currPath, "/dragMoment.mat"],dragM,"MAT"];*)



