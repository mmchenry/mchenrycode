function boatmen_model
% ODE model of boatmen hydrodynamics.
% This is a modified version of Blake, 1985



%% Parameter values

% Body density (kg m^-3)
rho_body  = 1030;

% Water density (kg m^-3)
rho_water = 1000;

% Body mass (kg)
mass_body = 23e-6;

% Viscosity of water (Pa s)
mu = 0.001;

% Body length (m) 
L = 8.5e-3;

% Wetted area of body (m^2)
S = 9e-6;

% Viscous drag coefficient of body (using value for sphere)
%k = 3*pi;

% Time to stop evaluation (s)
t_stop = 100e-3;

% Initial body speed (m/s)
U0 = 0;

% Initial body position (m)
X0 = 0;

% Angle of appendage at start of power stroke (rad)
gamma1  = 50 * pi/180;

% Angle of appendage at end of power stroke (rad)
gamma2  = -70 *pi/180;

% Beat period (s)
P = 50e-3;

% Drag coefficient of appendage
Cd_app = 1.1;

% Drag coefficient of the body
Cd_body = 1.07;

% Height of appendage (m)
h = 2e-3;

% Positon along appendage for base of paddle (m)
l_base = 6.5e-3;

% Positon along appendage for tip of paddle (m)
l_tip = 8.5e-3;


%% Scale parameters to non-dimensional units

% Define scaling constants
sL = L;
sT = 10^-3;
sM = mass_body;
sF = sM .* sL ./ sT^2;

% Declare global variables
global p

% Scale all parameters
p.rho_water = rho_water   /sM *sL^3;
p.rho_body  = rho_body    /sM *sL^3;
p.mass_body = mass_body   /sM;
p.mu        = mu          /(sF/sL^2) /sT;
p.L         = L           /sL;
%p.k         = k;
p.tspan     = [0 t_stop]  ./sT;
p.U0        = U0          /sL *sT;
p.X0        = X0          /sL;
p.gamma1    = gamma1;
p.gamma2    = gamma2;
p.P         = P           /sT;
p.Cd_app    = Cd_app;
p.Cd_body   = Cd_body;
p.h         = h           /sL;
p.l_base    = l_base      /sL;
p.l_tip     = l_tip       /sL;
p.S         = S           /(sL^2);

%clear mu L k t_stop rho_body rho_water S Cd_app Cd_body


%% Calculated & solver parameters

% Body volume (m^3)
%p.vol_body = (4/3) * pi * (p.L/2)^3;

% Solver options
options    = odeset('RelTol',1e-7);


%% Run numerical simulation 

[t,X] = ode45(@gov_eqn,p.tspan,[p.X0; p.U0],options);
%[t,X] = ode45(@gov_eqn,p.tspan,[p.X0; p.U0]);


%% Store results (convert values back to SI units)


% Appendage position (gama) and speed (alph)
[gama,alph] = app_kine(t,p.gamma1,p.gamma2,p.P);

% Thrust
T = app_thrust(gama,alph,X(:,2),p);
D = body_drag(X(:,2),p);

r.alpha  = alph    ./sT;
r.gamma  = gama;
r.thrust = T       .*sF;
r.drag   = D       .*sF;
r.t      = t       .*sT;
r.x      = X(:,1)  .*sL;
r.U      = X(:,2)  .*sL  ./sT;

clear U t X T D


%% Report results

ReMax_body   = L .* max(r.U) .* rho_water ./ mu;
ReMax_app    = max(abs(alph.*l_tip + r.U)) .* l_tip .* rho_water ./ mu; 

disp(' ')
disp([' Maximum Re of the body = ' num2str(ReMax_body)]);
disp(' ')
disp([' Maximum Re of the appendage = ' num2str(ReMax_app)]);
disp(' ')


%% Visualize results

% Plot
figure;
subplot(3,1,1)
[ax,h1,h2] = plotyy(r.t.*1000,r.gamma,r.t.*1000,r.alpha);
ylabel(ax(1),'gamma (rad)')
ylabel(ax(2),'alpha (rad/s)')
grid on

subplot(3,1,2)
plot(r.t.*1000,r.thrust.*10^6,'g',r.t.*1000,r.drag.*10^6,'-')
legend('thrust','drag')
ylabel('Force (micro N)')
grid on

subplot(3,1,3)
[ax2,h3,h4] = plotyy(r.t.*1000,r.U.*1000,r.t.*1000,r.alpha.*l_tip.*1000);
%legend('body','appendage')
xlabel('time (ms)')
ylabel(ax2(1),'Body speed (mm/s)')
ylabel(ax2(2),'Appendage speed (mm/s)')
ylim(ax2(1),[0 800])
ylim(ax2(2),[-800 0])
grid on



function dX = gov_eqn(t,X)
% ODE of the dynamics of the system

% Declare global variables
global p

% Body position
pos = X(1);

% Body speed
U   = X(2);

% Appendage position (gama) and speed (alph)
[gama,alph] = app_kine(t,p.gamma1,p.gamma2,p.P);

% Thrust
thrust = app_thrust(gama,alph,U,p);

% Drag
drag = body_drag(U,p);

% Body mass
%b_mass = (p.rho_body .* p.vol_body);

% Define output: speed
dX(1,1) = U;

% Define output: acceleration
dX(2,1) = (thrust + drag) ./ p.mass_body;


function [gama,alph] = app_kine(t,gamma1,gamma2,P)
% Kinematics of a single power stroke of the appendage
% gama - appendage angle
% alph - appendage velocity

gama = zeros(length(t),1);
alph = zeros(length(t),1);

idx = t<P;
gama(idx) = (gamma2 + gamma1)/2 + ( (gamma1 - gamma2)/2 .* cos( t(idx).*pi/P ) );
alph(idx) = -1/(2*P) .* ( (gamma1-gamma2) .* pi .* sin( pi.*t(idx)./P ) );

% Add trailing values that maintain the angle
idx2 = t>=P;
if max(idx2)
    gama(idx2) =gamma2.*ones(sum(idx2),1);
end


function T = app_thrust(gama,alph,U,p)
% Calculate thrust generated by appendage
% To avoid thrust going to infinity when alpha goes to zero 
% (due to the 1./(6.*alph) term)

% idx identifies the times when alpha is not zero
idx = alph~=0;

% Use limit (where alpha = 0) as thurst for times when alphs = 0
T(~idx) = -(p.l_base - p.l_tip) .* U(~idx).^2 .* cos(gama(~idx)).^2;

% Cut down alp, gama and U vectors to have same units as idx
alph = alph(idx);
gama = gama(idx);
U    = U(idx);

% Calculate thrust for when alpha is nonzero
T(idx) = (1./(6.*alph)) .* p.rho_water .* p.Cd_app .* p.h .* cos(gama) .* ...
         ( (p.l_tip.*alph  + U.*cos(gama)).^3 - ...
           (p.l_base.*alph + U.*cos(gama)).^3 );
       
% % Calculate thrust, if body velocity not included
% T(idx) = 0.5.*p.rho_water.*p.Cd_app.*p.h.*cos(gama).*...
%          (-1/3 .* p.l_base.^3 .* alph.^2 + p.l_tip.^3 .* alph.^2 ./ 3);

  
function D = body_drag(U,p) 
% Calculates drag force on the body

D = -0.5 .* p.S .* p.rho_water .* p.Cd_body .* abs(U) .* U;
