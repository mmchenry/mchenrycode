function d = point_analyze(imPath,echo_on)
% Analyzes relationship between body speed and appendage angle speed.
% Data structures generated by boatmanual


%% Parameters

visSteps = 1;

% Default smoothing tolerances
d.tolAng = 6.3e-6;
d.tolPos = 2e-3;

% Factor to multiple the scaling factor by when interactively selecting it
tolMultiplier = 0.75;

% Dynamic viscosity (Pa s)
mu = 1e-3;

% Density (kg m^-3)
rho = 1024;

if nargin < 2
    echo_on = 1;
end


%% Define directories

% Prompt for first frame, if not given
if nargin < 1 
    imPath= uigetdir(pwd,'Choose directory with kinematic data');
    
    if imPath==0
        return
    end
end


%% Check for data files

% Check for and load 'b' structure
if isempty(dir([imPath filesep 'boat_coords.mat']))
    error('No boat_coords.mat file!')
    
else
    load([imPath filesep 'boat_coords.mat'])
    
end

% Load frame rate and number of frames from either seq_info or seq_info2
if isempty(dir([imPath filesep 'seq_info.mat']))
    if empty([imPath filesep 'seq_info2.mat'])
        error('No seq_info or seq_info2 files present')
        
    else
        load([imPath filesep 'seq_info2.mat'])
        frame_rate  = p.framerate;
        
        clear p
    end
    
else
    load([imPath filesep 'seq_info.mat'])
    frame_rate   = seq.frame_rate;
    
    clear seq
end

% Vector of frame numbers
frames = 1:length(b.xNose);

% Index of frames for which there are data for both the wrist and tip
nonan = ~(isnan(b.xTip)  | isnan(b.xWrist) | isnan(b.xNose) | isnan(b.xTail));

% Time vector
time = (frames-1)./frame_rate;

% Chech that frames of data exist
if sum(nonan)==0
    error('No frames have all necessary points')
end


%% Run calibration, if none exists

if isempty(dir([imPath filesep 'cal_const.mat']))
    % Browse
    [cal_file,cal_path,tmp] = uigetfile('*.tif','Pick calibration image');
    
    if tmp==0
        return
    end
    
    imCal    = imread([cal_path filesep cal_file]);
    calconst = calibrate(imCal);
    
    save([imPath filesep 'cal_const.mat'],'calconst')
    
    clear imCal cal_file cal_path tmp
    
else  
    % Load calconst
    load([imPath filesep 'cal_const.mat'])
    
end

clear a


%% Calculate body and appendage kinematics

% Run if 'processed_data_v2.mat' is not present

if 1 %isempty(dir([imPath filesep 'processed_data_v2.mat']))
    
    % Define appendage angle wrt body coordinates -------------------------
    
    % Loop index
    idx = 1;
    
    bLength = mean(sqrt((b.xNose(nonan)-b.xTail(nonan)).^2 + ...
                        (b.yNose(nonan)-b.yTail(nonan)).^2));
    
    if 0*visSteps
        f = figure;
        set(f,'DoubleBuffer','on');
    end   
    
    % Define origin in global FOR
    origin = [mean([b.xNose b.xTail],2) ...
              mean([b.yNose b.yTail],2)];
   
    % Store time and center of body
    d.t = time(nonan);
    d.frames = frames(nonan);
    d.cntr_G = origin;
    
    %r = sqrt( (origin(:,1)-b.xTip(:)).^2 + (origin(:,1)-b.xTip(:)).^2 );
    
    % Step through frames to find local coordinates -----------------------
    for i = frames(nonan)    
        
        % Use head to define local system
        S = localSystem(origin(i,:),[b.xNose(i) b.yNose(i)]);
        
        % Transform current points to local system
        tip   = [b.xTip(i) b.yTip(i)];
        [tip(1),tip(2)] = globalToLocal(tip,origin(i,:),S);
        
        % Transform current points to local system
        wrist   = [b.xWrist(i) b.yWrist(i)];
        [wrist(1),wrist(2)] = globalToLocal(wrist,origin(i,:),S);
        
        % Transform current points to local system
        elbow   = [b.xElbow(i) b.yElbow(i)];
        [elbow(1),elbow(2)] = globalToLocal(elbow,origin,S);
        
        if 0*visSteps
            plot([wrist(1) tip(1)]./bLength,[wrist(2) tip(2)]./bLength,'o-',...
                 [wrist(1) elbow(1)]./bLength,[wrist(2) elbow(2)]./bLength,'r-')
            axis square
            axis([-1 1 -1 1])
            hold on
        end
        
        % Calculate appendage angle
        d.tip_L(idx,:)   = tip;
        d.wrist_L(idx,:) = wrist;
        d.elbow_L(idx,:) = elbow;
        
        % Step index
        idx = idx + 1;
        
        clear S tip wrist elbow
    end
    
    clear idx
    
    
    %% Identify power & recovery strokes
    
    % Find angle of tip
    angl = atan2(d.tip_L(:,2),d.tip_L(:,1));
    
    f = frames(nonan)';
    
    % Normalize 
    angl = (angl-mean(angl)) ./ range(angl);
    
    % Find valleys
    iVal = angl<-0.4;
    fVal = f(iVal);
    brks = [1; find(diff(fVal)>1); length(fVal)];
    
    for i = 1:length(brks)-1
       tVal(i) = mean(fVal(brks(i)+1:brks(i+1))) ./ frame_rate;     
    end
    
    clear brks iVal fVal 
    
    % Find peaks
    iPk  = angl>0.4;
    fPk  = f(iPk);
    brks = [1; find(diff(fPk)>1); length(fPk)];
    
    for i = 1:length(brks)-1
       tPk(i) = (mean(fPk(brks(i)+1:brks(i+1)))-1) ./ frame_rate;     
    end
   
    % Define indices for power and recovery strokes
    if tPk(1) < tVal(1)
        
        for i = 1:min([length(tPk) length(tVal)])
            d.pwr(i).idx = find((d.t >= tPk(i)) & (d.t < tVal(i)));
            d.pwr(i).t   = d.t(d.pwr(i).idx);
        end
        
        for i = 1:min([length(tPk)-1 length(tVal)])
            d.rtrn(i).idx  = find((d.t >= tVal(i)) & (d.t < tPk(i+1)));
            d.rtrn(i).t    = d.t(d.rtrn(i).idx);
        end
        
    else
        
        for i = 1:min([length(tPk) length(tVal)])
            d.pwr(i).idx = find((d.t >= tVal(i)) & (d.t < tPk(i)));
            d.pwr(i).t   = d.t(d.pwr(i).idx);
        end
        
        for i = 1:min([length(tPk) length(tVal)-1])
            d.rtrn(i).idx  = find((d.t >= tPk(i)) & (d.t < tVal(i+1)));
            d.rtrn(i).t    = d.t(d.rtrn(i).idx);
        end
        
    end
    
    clear tPk tVal brks fPk iPk
      
    % Plot identification of power and recover strokes
    if 0
        figure
        
        plot(d.t,angl,'ko')
        hold on
         for i = 1:length(d.pwr)
            plot(d.t(d.pwr(i).idx),angl(d.pwr(i).idx),'r+')
         end
         
         for i = 1:length(d.rtrn)
            plot(d.t(d.rtrn(i).idx),angl(d.rtrn(i).idx),'g+')
         end
         
         grid on
    end
    
    clear angl f iVal fVal brks
    
    
    %% Calculate appendage kinematics for power stroke
    
    % Loop through each power stroke
    for i = 1:length(d.pwr)
        
        % Points for current power stroke
        c_wrist = [d.wrist_L(d.pwr(i).idx,1) ...
                                d.wrist_L(d.pwr(i).idx,2)];
        c_tip   = [d.tip_L(d.pwr(i).idx,1) ...
                                d.tip_L(d.pwr(i).idx,2)];                   
        c_cntr  = [mean([c_wrist(:,1) c_tip(:,1)],2) ...
                        mean([c_wrist(:,2) c_tip(:,2)],2)];
                    
        % Calculate speed discretely             
        d.pwr(i).spd = [sqrt(  diff(c_cntr(:,1)).^2 + ...
                              diff(c_cntr(:,2)).^2  )./frame_rate]';
                          
        % Perform curve fit to velocity data   
        [A,tau,P] = fit_spd_func(d.pwr(i).t(2:end),d.pwr(i).spd);
        
        % Store parameters
        d.pwr(i).spd_A      = A;
        d.pwr(i).spd_tau    = tau;
        d.pwr(i).spd_P      = P;
        
        % Calculate angle
        d.pwr(i).angl = unwrap(atan2(c_tip(:,2)-c_wrist(:,2),...
                              c_tip(:,1)-c_wrist(:,1)));
        
        % Perform curve fit to angle data                          
        ang_amp = fit_ang_func(d.pwr(i).t,d.pwr(i).angl);
        
        % Store parameters
        d.pwr(i).ang_P = P;
        d.pwr(i).ang_amp = ang_amp;
           
        clear A tau P ang_amp c_wrist c_tip c_cntr
        
    end
    
    
    
    
    
    
    if 1
        
        figure
        for i = 1:length(d.pwr)
            subplot(2,1,1)
            plot(d.pwr(i).t(2:end),d.pwr(i).spd,'-o')
            ylabel('speed')
            subplot(2,1,2)
            plot(d.pwr(i).t,d.pwr(i).angl,'-o')
            ylabel('angle')
            pause
        end
        
        close
    end
    
    return
    
    
    if 1
        
        figure
        for i = 1:length(d.wrist_L(d.pwr(1).idx,1))
            plot([d.wrist_L(d.pwr(1).idx(i),1) d.tip_L(d.pwr(1).idx(i),1)],...
                 [d.wrist_L(d.pwr(1).idx(i),2) d.tip_L(d.pwr(1).idx(i),2)],'o-',...
                 0,0,'ro');
            hold on
        end
        axis equal
        grid on
    end
    
    
    
    
    
    
    % Calculate body position  --------------------------------------------
    
    
    
    % Calculate body center
    cntrX = mean([body.headX(nonan) body.tailX(nonan)],2);
    cntrY = mean([body.headY(nonan) body.tailY(nonan)],2);
    
    % Body position
    d.body_pos = [0; cumsum(sqrt(diff(cntrX).^2 + diff(cntrY).^2))];
    
        
    d.body_length = bLength.*calconst;
    
    clear bLength
    

    
    % Interactively select smoothing tolerance ----------------------------
    
    figure
    
    if echo_on
        disp(' ')
        disp('Select smoothing tolerance for angle and body -------------')
        disp('    Up arrow -   increase tolerance')
        disp('    Down arrow - decrease tolerance')
        disp(' ')
    end
    
    
    % Loop for angular tolerance
    while 1
        
        % Spline fit position data and calculate first derivative
        
        d.spAng = spaps(d.t,d.angl,d.tolAng);
        d.Uang  = fnval(fnder(d.spAng),d.t);

        subplot(3,1,1)
        plot(d.t,180.*d.angl./pi,'k.',d.t,180.*fnval(d.spAng,d.t)./pi,'k-')
        xlabel('time (s)')
        ylabel('Angle (deg)')
        grid on
        %title(['bLength = ' num2str(d.bLength) '  Re = ' num2str(d.Re_body)])
        title(['Angular tolerance = ' num2str(d.tolAng)])

        
        subplot(2,1,2)
        plot(d.t,d.Uang.*180/pi,'k-')
        xlabel('time (s)')
        ylabel('alpha (deg/s)')
        grid on
        
        [x,y,b] = ginput(1);
        
        % Up arrow
        if b==30
            
            d.tolAng = d.tolAng.*tolMultiplier; 
            
        % Down arrow
        elseif b==31
            
            d.tolAng = d.tolAng./tolMultiplier; 
            
        % Return    
        elseif isempty(b)
            
            break
            
        end
        
        clear x y b
    end
    
    
    % Loop for position tolerance
    while 1
        
        % Spline fit position data and calculate first derivative
        
        d.spPos = spaps(d.t,d.body_pos,d.tolPos);
        
        d.Ubody = fnval(fnder(d.spPos),d.t);
        
        subplot(2,1,1)
        plot(d.t,d.body_pos.*calconst,'k.',...
              d.t,fnval(d.spPos,d.t).*calconst,'k-')
        xlabel('time (s)')
        ylabel('Body position (SI Units)')
        grid on
        title(['Positon tolerance = ' num2str(d.tolPos)])
        
        subplot(2,1,2)
        plot(d.t,d.Ubody,'k-')
        xlabel('time (s)')
        ylabel('Normlized velocity')
        grid on
        
        [x,y,b] = ginput(1);
        
        if b==30
            
            d.tolPos = d.tolPos.*5; 
            
        elseif b==31
            
            d.tolPos = d.tolPos./5; 
            
        elseif isempty(b)
            
            break
            
        end
        
        clear x y b
    end
    
    close
    
    % Save data  ----------------------------------------------------------
    
    save([imPath filesep 'processed_data_v2.mat'],'d')
    
else
    
    % If file exists, load 'd' stucture
    if echo_on
        disp('Loading processed_data_v2.mat ...')
        load([imPath filesep 'processed_data_v2.mat'])
        disp(' ')     
    end
end



return


% Visualize data  -----------------------------------------------------
    
    figure
    
    subplot(4,1,1)
    plot(d.t,180.*d.angl./pi,'k.',d.t,180.*fnval(d.spAng,d.t)./pi,'k-')
    xlabel('time (s)')
    ylabel('Angle (deg)')
    grid on
    title(['bLength = ' num2str(d.bLength) '  Re = ' num2str(d.Re_body)])
    
    subplot(4,1,2)
    plot(d.t,d.body_pos.*calconst,'r.',d.t,fnval(d.spPos,d.t).*calconst,'r-')
    xlabel('time (s)')
    ylabel('Body position (SI Units)')
    grid on
    
    subplot(4,1,3)
    plot(d.t,d.Ubody,'r-',d.t,d.Uang,'k-')
    xlabel('time (s)')
    ylabel('Normlized velocity')
    grid on
    
    subplot(4,1,4)
    plot(d.t,d.Abody,'r-',d.t,d.Aang,'k-')
    xlabel('time (s)')
    ylabel('Normlized acceleration')
    grid on

return

    d.Re_body = (d.bLength/1000) .* max(d.Ubody.*calconst)./1000 .* rho ./ mu;
    
    % Normalize velocity
    d.Ubody = d.Ubody./range(d.Ubody);
    d.Uang = d.Uang./range(d.Uang);


    
    
function [A,phs,P] = fit_spd_func(t,spd)

% Declare global variables (fixed parameters)
global P phs

% Period btwn samples
dt = mean(diff(t));

% Zero-out time vector
%t = [t-t(1)+dt/2];
t = t-t(1);

% Period of speed oscillation
P = range(t);

% Phase shift (s)
phs = t(spd==max(spd))-range(t)/2;

% Approximate parameter value(s)
beta0(1) = max(spd);

A = nlinfit(t,spd,@spd_func,beta0);

%plot(t,spd,'o',t,spd_func(A,t),'r');


function A = fit_ang_func(t,ang)

% Declare global variables (fixed parameters)
global P 

% Period btwn samples
dt = mean(diff(t));

% Zero-out time vector
t = [t-t(1)]';

P = range(t);
% Period of speed oscillation
%P = 1.5.*range(t);

% Phase shift (s)
ang = ang-min(ang);

% Approximate parameter value(s)
beta0(1) = range(t)/2;

% Find best fit for amplitude of angular change
A = nlinfit(t,ang,@ang_func,beta0);

%plot(t,ang,'o',t,ang_func(A,t),'r');


function y = spd_func(b,t)
% Function that defines the speed of the power stroke over time

% Declare global variables (fixed parameters)
global  phs P

% Define parameter(s) to be found with nlinfit
A = b(1);

% The equation
y = A.*sin(pi.*(t-phs)./(1.5*P)).^2;


function y = ang_func(b,t)
% Defines angle of power stroke over time

global P

% Define parameter(s) to be found with nlinfit
A = b(1);

% The equation
y = A.*sin(pi.*(t)./(2.*(1.1*P))).^2;


    
function S = localSystem(P1,P2)
% Defines a transformation vector for a local coordinate system in an
% inertial frame of reference.  Uses P1 as the origin and P2 to find the
% direction of the x-axis.  Coordinates must be (1x2) vectors.

if size(P1,1)~=1 || size(P1,2)~=2 ||...
   size(P2,1)~=1 || size(P2,2)~=2
    error('Coordinates must be (1x2) vectors');
end

% yAxis       = (P2-P1)./norm(P2-P1);
% xAxis       = [yAxis(2); -yAxis(1)];
% S           = [xAxis yAxis'];

xAxis       = (P2-P1)./norm(P2-P1);
yAxis       = [xAxis(2);-xAxis(1)];
S           = [xAxis' yAxis];


function [x,y] = localToGlobal(pts,origin,S)

if size(pts,2)~=2 || size(origin,2)~=2 
    error('Coordinates must be a (nx2) vector');
end

pts         = [inv(S)'*pts']';
pts(:,1)    = pts(:,1)+origin(1);
pts(:,2)    = pts(:,2)+origin(2);
x           = pts(:,1);
y           = pts(:,2);


function [x,y] = globalToLocal(pts,origin,S)

if size(pts,2)~=2 || size(origin,2)~=2 
    error('Coordinates must be a (nx2) vector');
end

pts(:,1)    = pts(:,1)-origin(1);
pts(:,2)    = pts(:,2)-origin(2);
pts         = [S'*pts']';
x           = pts(:,1);
y           = pts(:,2);


function data_filtered = butter_filt(data,sample_rate,cut_freq,type) 
% High-pass or low-pass butterworth filter

% All frequency values are in Hz.

% Nyquist freq.
Nqst = sample_rate/2;   

% Calculate stopband frequency
if strcmp(type,'high')
    stop_freq = max([(cut_freq - Nqst/10) .01]);  

elseif strcmp(type,'low')
    stop_freq = min([(cut_freq + Nqst/10) (Nqst-.01)]); 
 
end

% Stopband Attenuation (dB)
Astop = 10;

% Passband Ripple (dB)
Apass = 1;   

% Normalise the cutoff freq. to the Nyquist freq
Wp = cut_freq/Nqst;

% Normalise the stoppass freq. to the Nyquist freq
Ws = stop_freq/Nqst;

% Check cutoff
if (Wp > 1) || (Ws > 1)
    error('Cutoff or bandpass frequencies cannot exceed the Nyquist freq')
end

% Calculate the order from the parameters using BUTTORD.
[N,Fc] = buttord(Wp, Ws, Apass, Astop);    
    
% Calculate the zpk values using the BUTTER function.
[B A] = butter(N, Fc, type);

% Plot frequency reponse
%freqz(B,A,512,sample_rate); 

% Filter the data
data_filtered   = filtfilt(B,A,data); 
