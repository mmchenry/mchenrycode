function d = point_analyze(imPath)
% Analyzes relationship between body speed and appendage angle speed.
% Data structures generated by boatmanual


%% Parameters

visSteps = 1;

% Default smoothing tolerances
d.tolAng = 6.3e-6;
d.tolPos = 2e-3;

% Factor to multiple the scaling factor by when interactively selecting it
tolMultiplier = 0.75;

% Dynamic viscosity (Pa s)
mu = 1e-3;

% Density (kg m^-3)
rho = 1024;

if nargin < 2
    echo_on = 1;
end

% Cutoff freq for low pass filter when calculating speed (Hz)
cut_freq = 80;


%% Define directories

% Prompt for first frame, if not given
if nargin < 1 
    imPath= uigetdir(pwd,'Choose directory with kinematic data');
    
    if imPath==0
        return
    end
end


%% Check for data files

% Check for and load 'b' structure
if isempty(dir([imPath filesep 'boat_coords.mat']))
    error('No boat_coords.mat file!')
    
else
    load([imPath filesep 'boat_coords.mat'])
    
end

% Load frame rate and number of frames from either seq_info or seq_info2
if isempty(dir([imPath filesep 'seq_info.mat']))
    if isempty([imPath filesep 'seq_info2.mat'])
        error('No seq_info or seq_info2 files present')
        
    else
        load([imPath filesep 'seq_info2.mat'])
        frame_rate  = p.framerate;
        
        clear p
    end
    
else
    load([imPath filesep 'seq_info.mat'])
    frame_rate   = seq.frame_rate;
    
    clear seq
end

% Vector of frame numbers
frames = 1:length(b.xNose);

% Index of frames for which there are data for both the wrist and tip
nonan = ~(isnan(b.xTip)  | isnan(b.xWrist) | isnan(b.xNose) | isnan(b.xTail));

% Time vector
time = (frames-1)./frame_rate;

% Chech that frames of data exist
if sum(nonan)==0
    error('No frames have all necessary points')
end


%% Run calibration, if none exists

if isempty(dir([imPath filesep 'cal_const.mat']))
    % Browse
    [cal_file,cal_path,tmp] = uigetfile('*.tif','Pick calibration image');
    
    if tmp==0
        return
    end
    
    imCal    = imread([cal_path filesep cal_file]);
    calconst = calibrate(imCal);
    
    save([imPath filesep 'cal_const.mat'],'calconst')
    
    clear imCal cal_file cal_path tmp
    
else  
    % Load calconst
    load([imPath filesep 'cal_const.mat'])
    
end

% Convert to m/pix
calconst = calconst/1000;

clear a


%% Calculate body and appendage kinematics


% Define appendage angle wrt body coordinates -------------------------

% Loop index
idx = 1;

if 0*visSteps
    f = figure;
    set(f,'DoubleBuffer','on');
end

% Define origin in global FOR
origin = [mean([b.xNose b.xTail],2) ...
    mean([b.yNose b.yTail],2)];

% Store time and center of body
d.t = time(nonan);
d.frames = frames(nonan);
d.cntr_G = origin(nonan,:) .* calconst;

% Filter COM data
d.cntr_G  = [butter_filt(d.cntr_G(:,1),1./mean(diff(time)),cut_freq,'low') ...
               butter_filt(d.cntr_G(:,2),1./mean(diff(time)),cut_freq,'low')];

%r = sqrt( (origin(:,1)-b.xTip(:)).^2 + (origin(:,1)-b.xTip(:)).^2 );

% Step through frames to find local coordinates -----------------------
for i = frames(nonan)
    
    % Use head to define local system
    S = localSystem(origin(i,:),[b.xNose(i) b.yNose(i)]);
    
    % Transform current points to local system
    tip   = [b.xTip(i) b.yTip(i)];
    [tip(1),tip(2)] = globalToLocal(tip,origin(i,:),S);
    
    % Transform current points to local system
    wrist   = [b.xWrist(i) b.yWrist(i)];
    [wrist(1),wrist(2)] = globalToLocal(wrist,origin(i,:),S);
    
    % Transform current points to local system
    elbow   = [b.xElbow(i) b.yElbow(i)];
    [elbow(1),elbow(2)] = globalToLocal(elbow,origin,S);
    
    % Filter point data 
    
    
    if 0*visSteps
        plot([wrist(1) tip(1)],[wrist(2) tip(2)],'o-',...
            [wrist(1) elbow(1)],[wrist(2) elbow(2)],'r-')
        axis square
        hold on
    end
    
    % Store points & calibrate
    d.tip_L(idx,:)   = tip    .* calconst;
    d.wrist_L(idx,:) = wrist  .* calconst;
    d.elbow_L(idx,:) = elbow  .* calconst;
              
    % Step index
    idx = idx + 1;
    
    clear S tip wrist elbow
end

% Filter coordinate data
d.wrist_L = [butter_filt(d.wrist_L(:,1),1./mean(diff(time)),cut_freq,'low') ...
             butter_filt(d.wrist_L(:,2),1./mean(diff(time)),cut_freq,'low')];
d.tip_L   =  [butter_filt(d.tip_L(:,1),1./mean(diff(time)),cut_freq,'low') ...
              butter_filt(d.tip_L(:,2),1./mean(diff(time)),cut_freq,'low')];
d.elbow_L =  [butter_filt(d.elbow_L(:,1),1./mean(diff(time)),cut_freq,'low') ...
              butter_filt(d.elbow_L(:,2),1./mean(diff(time)),cut_freq,'low')];

clear idx

%% Visualize whole sequence

if 0
    cntr_G  = d.cntr_G;
    c_wrist = d.wrist_L;
    c_tip   =  d.tip_L;
           
%     c_wrist = [d.wrist_L(:,1) d.wrist_L(:,2)];
%     c_tip   = [d.tip_L(:,1) d.tip_L(:,2)];
    c_cntr  = [mean([c_wrist(:,1) c_tip(:,1)],2) ...
               mean([c_wrist(:,2) c_tip(:,2)],2)];
           
    % Calculate app angle
    angl_tmp = atan2(c_tip(:,2),c_tip(:,1));
    
    % Calculate app speed discretely
    spd_tmp = [sqrt(  diff(c_cntr(:,1)).^2 + ...
               diff(c_cntr(:,2)).^2  ).*frame_rate]';
    
    % Calculate COM speed
    U_tmp = sqrt(diff(cntr_G(:,1)).^2 + diff(cntr_G(:,1)).^2)./diff(d.t');

    % Filter data
    spd_tmp = butter_filt(spd_tmp,1./mean(diff(time)),cut_freq,'low');
    angl_tmp = butter_filt(angl_tmp,1./mean(diff(time)),cut_freq,'low');
    %U_tmp = butter_filt(U_tmp,1./mean(diff(time)),cut_freq,'low');
    
    figure
    
    subplot(3,1,1)
    plot(d.t,angl_tmp.*180./pi)
    grid on
    xlabel('time (s)')
    ylabel('Appendage angle (deg)')
    
    subplot(3,1,2)
    plot(d.t(2:end),1000.*spd_tmp)
    grid on
    xlabel('time (s)')
    ylabel('Appendage speed (mm/s)')

    
    subplot(3,1,3)
    plot(d.t(2:end),1000.*U_tmp)
    grid on
    xlabel('time (s)')
    ylabel('Body speed (mm/s)')
    
    clear angl_tmp spd_tmp U_tmp cntr_G
end

%% Identify power & recovery strokes

% Threshold for finding peaks
thresh = 0.2;

% Find angle of tip
angl = atan2(d.tip_L(:,2),d.tip_L(:,1));

f = frames(nonan)';

% Normalize
angl = (angl-mean(angl)) ./ range(angl);

% Find valleys
iVal = angl < -thresh;
fVal = f(iVal);
brks = [1; find(diff(fVal)>6); length(fVal)];

for i = 1:length(brks)-1
    tVal(i) = mean(fVal(brks(i)+1:brks(i+1))) ./ frame_rate;
end

clear brks iVal fVal

% Find peaks
iPk  = angl > thresh;
fPk  = f(iPk);
brks = [1; find(diff(fPk)>6); length(fPk)];

for i = 1:length(brks)-1
    tPk(i) = (mean(fPk(brks(i)+1:brks(i+1)))-1) ./ frame_rate;
end

% Define indices for power and recovery strokes
if tPk(1) < tVal(1)
    
    for i = 1:min([length(tPk) length(tVal)])
        d.rtrn(i).idx = find((d.t >= tPk(i)) & (d.t < tVal(i)));
        d.rtrn(i).t   = d.t(d.rtrn(i).idx);
    end
    
    for i = 1:min([length(tPk)-1 length(tVal)])
        d.pwr(i).idx  = find((d.t >= tVal(i)) & (d.t < tPk(i+1)));
        d.pwr(i).t    = d.t(d.pwr(i).idx);
    end
    
else
    
    %         if min([length(tVal) length(tPk)]) > 2
    %             for i=1:min([length(tVal) length(tPk)]);
    %                 if tVal(i)-tPk(i) > 0
    %
    %                 end
    %             end
    %         end
    %
    for i = 1:min([length(tPk) length(tVal)])
        d.pwr(i).idx = find((d.t >= tVal(i)) & (d.t < tPk(i)));
        d.pwr(i).t   = d.t(d.pwr(i).idx);
    end
    
    for i = 1:min([length(tPk) length(tVal)-1])
        d.rtrn(i).idx  = find((d.t >= tPk(i)) & (d.t < tVal(i+1)));
        d.rtrn(i).t    = d.t(d.rtrn(i).idx);
    end
    
end

clear tPk tVal brks fPk iPk thresh

% Plot identification of power and recover strokes
if 0
    figure
    
    plot(d.t,angl,'ko')
    hold on
    for i = 1:length(d.pwr)
        plot(d.t(d.pwr(i).idx),angl(d.pwr(i).idx),'r+')
    end
    
    for i = 1:length(d.rtrn)
        plot(d.t(d.rtrn(i).idx),angl(d.rtrn(i).idx),'g+')
    end
    
    grid on
end

clear angl f iVal fVal brks


%% Calculate appendage kinematics for power stroke

d.num_strokes = 3;

% Loop through each power stroke
for i = 1:length(d.pwr)
    
    % Points for current power stroke
    c_wrist = [d.wrist_L(d.pwr(i).idx,1) ...
        d.wrist_L(d.pwr(i).idx,2)];
    c_tip   = [d.tip_L(d.pwr(i).idx,1) ...
        d.tip_L(d.pwr(i).idx,2)];
    c_cntr  = [mean([c_wrist(:,1) c_tip(:,1)],2) ...
        mean([c_wrist(:,2) c_tip(:,2)],2)];
    
    % Calculate speed discretely
    spd1 = [sqrt(  diff(c_cntr(:,1)).^2 + ...
        diff(c_cntr(:,2)).^2  ).*frame_rate]';
    
    d.pwr(i).spd = spd1;
    
    %d.pwr(i).spd = butter_filt(spd1,1./mean(diff(time)),cut_freq,'low'); 
    
    clear spd1
    
    % Perform curve fit to velocity data
    [A,phs,P,spd_0] = fit_spd_func(d.pwr(i).t(2:end),d.pwr(i).spd);
    
    % Store parameters
    d.pwr(i).spd_A      = A;
    d.pwr(i).spd_phs    = phs;
    d.pwr(i).spd_P      = P;
    d.pwr(i).spd_0      = spd_0;
    
    % Calculate angle
    d.pwr(i).angl = unwrap(atan2(c_tip(:,2)-c_wrist(:,2),...
        c_tip(:,1)-c_wrist(:,1)));
    
    % Perform curve fit to angle data
    [ang_amp,ang_start] = fit_ang_func(d.pwr(i).t,d.pwr(i).angl);
    
    % Store parameters
    d.pwr(i).ang_P = P;
    d.pwr(i).ang_amp = ang_amp;
    d.pwr(i).ang_start = ang_start;
    
    clear A tau P ang_amp c_wrist c_tip c_cntr ang_start spd_0
    
end


%% Calculate period of return stroke

for i = 1:length(d.rtrn) 
    d.rtrn(i).period = range(d.rtrn(i).t);   
end


%% Calculate appendage and body dimensions

bLength = mean(sqrt((b.xNose(nonan)-b.xTail(nonan)).^2 + ...
    (b.yNose(nonan)-b.yTail(nonan)).^2));

appLength = mean(sqrt((b.xWrist(nonan)-b.xTip(nonan)).^2 + ...
    (b.yWrist(nonan)-b.yTip(nonan)).^2));

d.body_len   = bLength.*calconst;
d.app_len    = appLength.*calconst;


%% Plot angle and speed data

if 0
    figure
    for i = 1:length(d.pwr)
        subplot(2,1,1)
        plot(d.pwr(i).t(2:end),d.pwr(i).spd.*1000,'-o')
        ylabel('speed (mm/s)')
        subplot(2,1,2)
        plot(d.pwr(i).t,d.pwr(i).angl,'-o')
        ylabel('angle')
       % pause
    end
    
    close
end


%% Plot power stroke data

if 0    
    figure
    for i = 1:length(d.wrist_L(d.pwr(1).idx,1))
        plot([d.wrist_L(d.pwr(1).idx(i),1) d.tip_L(d.pwr(1).idx(i),1)],...
            [d.wrist_L(d.pwr(1).idx(i),2) d.tip_L(d.pwr(1).idx(i),2)],'o-',...
            0,0,'ro');
        hold on
    end
    axis equal
    grid on
end



    
    
function [A,phs,P,spd_0] = fit_spd_func(t,spd)

% Declare global variables (fixed parameters)
global P phs spd_0

% Period btwn samples
dt = mean(diff(t));

% Zero-out time vector
%t = [t-t(1)+dt/2];
t = t-t(1);

% Period of speed oscillation
P = range(t);

% Initial speed
spd_0 = spd(1);

% Approximate parameter value(s)
beta0(1) = max(spd);
beta0(2) = t(spd==max(spd))-range(t)/2;

bta = nlinfit(t,spd,@spd_func,beta0);

%plot(t,spd,'o',t,spd_func(bta,t),'r');

A = bta(1);
phs = bta(2);


function [A,ang_start] = fit_ang_func(t,ang)

% Declare global variables (fixed parameters)
global P ang_start

% Period btwn samples
dt = mean(diff(t));

% Zero-out time vector
t = [t-t(1)]';

P = range(t);
% Period of speed oscillation
%P = 1.5.*range(t);

ang_start = min(ang);


%ang = ang - ang_start;

% Approximate parameter value(s)
beta0(1) = range(t)/2;

% Find best fit for amplitude of angular change
A = nlinfit(t,ang,@ang_func,beta0);

%plot(t,ang,'o',t,ang_func(A,t),'r');

function y = spd_func(b,t)
% Function that defines the speed of the power stroke over time

% Declare global variables (fixed parameters)
global   P spd_0

% Define parameter(s) to be found with nlinfit
A = b(1);
phs = b(2);

% The equation
y = spd_0 + A.*sin(pi.*(t-phs)./(1.5*P)).^2;


function y = ang_func(b,t)
% Defines angle of power stroke over time

global P ang_start

% Define parameter(s) to be found with nlinfit
A = b(1);

% The equation
y = ang_start + A.*sin(pi.*(t)./(2.*(1.1*P))).^2;

    
function S = localSystem(P1,P2)
% Defines a transformation vector for a local coordinate system in an
% inertial frame of reference.  Uses P1 as the origin and P2 to find the
% direction of the x-axis.  Coordinates must be (1x2) vectors.

if size(P1,1)~=1 || size(P1,2)~=2 ||...
   size(P2,1)~=1 || size(P2,2)~=2
    error('Coordinates must be (1x2) vectors');
end

% yAxis       = (P2-P1)./norm(P2-P1);
% xAxis       = [yAxis(2); -yAxis(1)];
% S           = [xAxis yAxis'];

xAxis       = (P2-P1)./norm(P2-P1);
yAxis       = [xAxis(2);-xAxis(1)];
S           = [xAxis' yAxis];


function [x,y] = localToGlobal(pts,origin,S)

if size(pts,2)~=2 || size(origin,2)~=2 
    error('Coordinates must be a (nx2) vector');
end

pts         = [inv(S)'*pts']';
pts(:,1)    = pts(:,1)+origin(1);
pts(:,2)    = pts(:,2)+origin(2);
x           = pts(:,1);
y           = pts(:,2);


function [x,y] = globalToLocal(pts,origin,S)

if size(pts,2)~=2 || size(origin,2)~=2 
    error('Coordinates must be a (nx2) vector');
end

pts(:,1)    = pts(:,1)-origin(1);
pts(:,2)    = pts(:,2)-origin(2);
pts         = [S'*pts']';
x           = pts(:,1);
y           = pts(:,2);


function data_filtered = butter_filt(data,sample_rate,cut_freq,type) 
% High-pass or low-pass butterworth filter

% All frequency values are in Hz.

% Nyquist freq.
Nqst = sample_rate/2;   

% Calculate stopband frequency
if strcmp(type,'high')
    stop_freq = max([(cut_freq - Nqst/10) .01]);  

elseif strcmp(type,'low')
    stop_freq = min([(cut_freq + Nqst/10) (Nqst-.01)]); 
 
end

% Stopband Attenuation (dB)
Astop = 10;

% Passband Ripple (dB)
Apass = 1;   

% Normalise the cutoff freq. to the Nyquist freq
Wp = cut_freq/Nqst;

% Normalise the stoppass freq. to the Nyquist freq
Ws = stop_freq/Nqst;

% Check cutoff
if (Wp > 1) || (Ws > 1)
    error('Cutoff or bandpass frequencies cannot exceed the Nyquist freq')
end

% Calculate the order from the parameters using BUTTORD.
[N,Fc] = buttord(Wp, Ws, Apass, Astop);    
    
% Calculate the zpk values using the BUTTER function.
[B A] = butter(N, Fc, type);

% Plot frequency reponse
%freqz(B,A,512,sample_rate); 

% Filter the data
data_filtered   = filtfilt(B,A,data); 
