function d = point_analyze(imPath)
% Analyzes relationship between body speed and appendage angle speed.
% Data structures generated by boatmanual


%% Parameters

visSteps = 1;


% Factor to multiple the scaling factor by when interactively selecting it
tolMultiplier = 0.75;

% Dynamic viscosity (Pa s)
mu = 1e-3;

% Density (kg m^-3)
rho = 1024;

if nargin < 2
    echo_on = 1;
end

% Cutoff freq for low pass filter when calculating speed (Hz)
cut_freq = 90;

% Tolerance for smoothing splines of angle data
tol_ang = 1e-4;

% Tolerance for smoothing splines of speed data
tol_spd = 1e-7;


%% Define directories

% Prompt for first frame, if not given
if nargin < 1 
    imPath= uigetdir(pwd,'Choose directory with kinematic data');
    
    if imPath==0
        return
    end
end


%% Check for data files

% Check for and load 'b' structure
if isempty(dir([imPath filesep 'boat_coords.mat']))
    error('No boat_coords.mat file!')
    
else
    load([imPath filesep 'boat_coords.mat'])
    
end

% Load frame rate and number of frames from either seq_info or seq_info2
if isempty(dir([imPath filesep 'seq_info.mat']))
    if isempty([imPath filesep 'seq_info2.mat'])
        error('No seq_info or seq_info2 files present')
        
    else
        load([imPath filesep 'seq_info2.mat'])
        frame_rate  = p.framerate;
        
        clear p
    end
    
else
    load([imPath filesep 'seq_info.mat'])
    frame_rate   = seq.frame_rate;
    
    clear seq
end

% Vector of frame numbers
frames = 1:length(b.xNose);

% Index of frames for which there are data for both the wrist and tip
nonan = ~(isnan(b.xTip)  | isnan(b.xWrist) | isnan(b.xNose) | isnan(b.xTail));

% Time vector
time = (frames-1)./frame_rate;

% Chech that frames of data exist
if sum(nonan)==0
    error('No frames have all necessary points')
end


%% Run calibration, if none exists

if isempty(dir([imPath filesep 'cal_const.mat']))
    % Browse
    [cal_file,cal_path,tmp] = uigetfile('*.tif','Pick calibration image');
    
    if tmp==0
        return
    end
    
    imCal    = imread([cal_path filesep cal_file]);
    calconst = calibrate(imCal);
    
    save([imPath filesep 'cal_const.mat'],'calconst')
    
    clear imCal cal_file cal_path tmp
    
else  
    % Load calconst
    load([imPath filesep 'cal_const.mat'])
    
end

% Convert to m/pix
calconst = calconst/1000;

clear a


%% Calculate body and appendage kinematics


% Define appendage angle wrt body coordinates -------------------------

% Loop index
idx = 1;

if 0*visSteps
    f = figure;
    set(f,'DoubleBuffer','on');
end

% Define origin in global FOR
origin = [mean([b.xNose b.xTail],2) ...
    mean([b.yNose b.yTail],2)];

% Store time and center of body
d.t = time(nonan);
d.frames = frames(nonan);
d.cntr_G = origin(nonan,:) .* calconst;

% Filter COM data
d.cntr_G  = [butter_filt(d.cntr_G(:,1),1./mean(diff(time)),cut_freq,'low') ...
               butter_filt(d.cntr_G(:,2),1./mean(diff(time)),cut_freq,'low')];

%r = sqrt( (origin(:,1)-b.xTip(:)).^2 + (origin(:,1)-b.xTip(:)).^2 );

% Step through frames to find local coordinates -----------------------
for i = frames(nonan)
    
    % Use head to define local system
    S = localSystem(origin(i,:),[b.xNose(i) b.yNose(i)]);
    
    % Transform current points to local system
    tip   = [b.xTip(i) b.yTip(i)];
    [tip(1),tip(2)] = globalToLocal(tip,origin(i,:),S);
    
    % Transform current points to local system
    wrist   = [b.xWrist(i) b.yWrist(i)];
    [wrist(1),wrist(2)] = globalToLocal(wrist,origin(i,:),S);
    
    % Transform current points to local system
    elbow   = [b.xElbow(i) b.yElbow(i)];
    [elbow(1),elbow(2)] = globalToLocal(elbow,origin,S);
    
    % Filter point data 
    
    
    if 0*visSteps
        plot([wrist(1) tip(1)],[wrist(2) tip(2)],'o-',...
            [wrist(1) elbow(1)],[wrist(2) elbow(2)],'r-')
        axis square
        hold on
    end
    
    % Store points & calibrate
    d.tip_L(idx,:)   = tip    .* calconst;
    d.wrist_L(idx,:) = wrist  .* calconst;
    d.elbow_L(idx,:) = elbow  .* calconst;
              
    % Step index
    idx = idx + 1;
    
    clear S tip wrist elbow
end


%% Filter and spline fit the data

% Filter coordinate data
d.wrist_L = [butter_filt(d.wrist_L(:,1),1./mean(diff(time)),cut_freq,'low') ...
             butter_filt(d.wrist_L(:,2),1./mean(diff(time)),cut_freq,'low')];
d.tip_L   =  [butter_filt(d.tip_L(:,1),1./mean(diff(time)),cut_freq,'low') ...
              butter_filt(d.tip_L(:,2),1./mean(diff(time)),cut_freq,'low')];
d.elbow_L =  [butter_filt(d.elbow_L(:,1),1./mean(diff(time)),cut_freq,'low') ...
              butter_filt(d.elbow_L(:,2),1./mean(diff(time)),cut_freq,'low')];

% Define center position of paddle   
c_cntr  = [mean([d.wrist_L(:,1) d.tip_L(:,1)],2) ...
        mean([d.wrist_L(:,2) d.tip_L(:,2)],2)];
    
% Define angle of paddle
ang_pd = unwrap(atan2(d.tip_L(:,2)-d.wrist_L(:,2),...
                      d.tip_L(:,1)-d.wrist_L(:,1)));
                  
% Define angular position of wrist
ang_wrst = unwrap(atan2(d.wrist_L(:,2),d.wrist_L(:,1)));                  

% Define speed of paddle & body
spd1    = [sqrt(  diff(c_cntr(:,1)).^2 + ...
           diff(c_cntr(:,2)).^2  ).*frame_rate]';
spd_bod = [sqrt(  diff(d.cntr_G(:,1)).^2 + ...
           diff(d.cntr_G(:,2)).^2  ).*frame_rate]';
t_spd = d.t(1:end-1)+mean(diff(d.t))/2;

% Spline for angle of paddle
d.sp_ang_pd = spaps(d.t,ang_pd,tol_ang);

% Spline for anglular position of paddle
d.sp_ang_wrst = spaps(d.t,ang_wrst,tol_ang);

% Spline for angle of paddle
d.sp_ang_pd = spaps(d.t,ang_pd,tol_ang);

% Spline for speed of paddle
d.sp_spd_pd = spaps(t_spd,spd1,tol_spd);

% Spline for speed of body
d.sp_spd_bod = spaps(t_spd,spd_bod,tol_spd);

% Visualize spline fits
if 0
    subplot(4,1,1)
    plot(d.t,ang_pd,'ok',d.t,fnval(d.sp_ang_pd,d.t),'-k')
    ylabel('angle of paddle')
    grid on
    
    subplot(4,1,2)
    plot(d.t,ang_wrst,'ok',d.t,fnval(d.sp_ang_wrst,d.t),'-k')
    ylabel('angle of wrist')
    grid on
    
    subplot(4,1,3)
    plot(t_spd,spd1,'ok',t_spd,fnval(d.sp_spd_pd,t_spd),'-k')
    ylabel('speed of appendage')
    grid on
    
    subplot(4,1,4)
    plot(t_spd,spd_bod,'ok',t_spd,fnval(d.sp_spd_bod,t_spd),'-k')
    ylabel('speed of body')
    grid on   
    pause
end

clear idx t_spd spd1 ang_pd ang_wrst c_cntr


%% Identify power & recovery strokes

% Splines of angular position of paddle
sp    = d.sp_ang_wrst;
Dsp   = fnder(sp,1);
D2sp  = fnder(sp,2);

% Find reversals
t_rev = fnzeros(Dsp,[d.t(1) d.t(end)]);
t_rev = t_rev(1,:);

% Find sign of second derivative
D2sgn = fnval(D2sp,t_rev)./abs(fnval(D2sp,t_rev));

% Locate times of starts of power and return strokes
t_pwr  = t_rev(D2sgn==1);
t_rtrn = t_rev(D2sgn==-1);

for i = 1:length(t_pwr)
    % Find end of power stroke
    t_end = t_rtrn(find(t_rtrn>=t_pwr(i),1,'first'));
    if isempty(t_end)
        break
    else
        if i==length(t_pwr)
            d.t_pwr(i,:) = [t_pwr(i) t_end d.t(end)];
        else
            d.t_pwr(i,:) = [t_pwr(i) t_end t_pwr(i+1)];
        end
    end
end

% Plot identification of power and recover strokes
if 0
    %figure
    
    plot(d.t,fnval(sp,d.t),'k-')
    yL = ylim;
    hold on
    for i = 1:length(d.t_pwr)
        plot([d.t_pwr(i,1) d.t_pwr(i,1)],yL,'r-',...
             [d.t_pwr(i,2) d.t_pwr(i,2)],yL,'g-')
    end
    hold off
    %grid on
    pause
end

clear sp Dsp D2sp t_rev D2sgn t_pwr t_rtrn


%% Calculate appendage and body dimensions

bLength = mean(sqrt((b.xNose(nonan)-b.xTail(nonan)).^2 + ...
    (b.yNose(nonan)-b.yTail(nonan)).^2));

appLength = mean(sqrt((b.xWrist(nonan)-b.xTip(nonan)).^2 + ...
    (b.yWrist(nonan)-b.yTip(nonan)).^2));

d.body_len   = bLength.*calconst;
d.app_len    = appLength.*calconst;


    
function S = localSystem(P1,P2)
% Defines a transformation vector for a local coordinate system in an
% inertial frame of reference.  Uses P1 as the origin and P2 to find the
% direction of the x-axis.  Coordinates must be (1x2) vectors.

if size(P1,1)~=1 || size(P1,2)~=2 ||...
   size(P2,1)~=1 || size(P2,2)~=2
    error('Coordinates must be (1x2) vectors');
end

% yAxis       = (P2-P1)./norm(P2-P1);
% xAxis       = [yAxis(2); -yAxis(1)];
% S           = [xAxis yAxis'];

xAxis       = (P2-P1)./norm(P2-P1);
yAxis       = [xAxis(2);-xAxis(1)];
S           = [xAxis' yAxis];


function [x,y] = localToGlobal(pts,origin,S)

if size(pts,2)~=2 || size(origin,2)~=2 
    error('Coordinates must be a (nx2) vector');
end

pts         = [inv(S)'*pts']';
pts(:,1)    = pts(:,1)+origin(1);
pts(:,2)    = pts(:,2)+origin(2);
x           = pts(:,1);
y           = pts(:,2);


function [x,y] = globalToLocal(pts,origin,S)

if size(pts,2)~=2 || size(origin,2)~=2 
    error('Coordinates must be a (nx2) vector');
end

pts(:,1)    = pts(:,1)-origin(1);
pts(:,2)    = pts(:,2)-origin(2);
pts         = [S'*pts']';
x           = pts(:,1);
y           = pts(:,2);


function data_filtered = butter_filt(data,sample_rate,cut_freq,type) 
% High-pass or low-pass butterworth filter

% All frequency values are in Hz.

% Nyquist freq.
Nqst = sample_rate/2;   

% Calculate stopband frequency
if strcmp(type,'high')
    stop_freq = max([(cut_freq - Nqst/10) .01]);  

elseif strcmp(type,'low')
    stop_freq = min([(cut_freq + Nqst/10) (Nqst-.01)]); 
 
end

% Stopband Attenuation (dB)
Astop = 10;

% Passband Ripple (dB)
Apass = 1;   

% Normalise the cutoff freq. to the Nyquist freq
Wp = cut_freq/Nqst;

% Normalise the stoppass freq. to the Nyquist freq
Ws = stop_freq/Nqst;

% Check cutoff
if (Wp > 1) || (Ws > 1)
    error('Cutoff or bandpass frequencies cannot exceed the Nyquist freq')
end

% Calculate the order from the parameters using BUTTORD.
[N,Fc] = buttord(Wp, Ws, Apass, Astop);    
    
% Calculate the zpk values using the BUTTER function.
[B A] = butter(N, Fc, type);

% Plot frequency reponse
%freqz(B,A,512,sample_rate); 

% Filter the data
data_filtered   = filtfilt(B,A,data); 
